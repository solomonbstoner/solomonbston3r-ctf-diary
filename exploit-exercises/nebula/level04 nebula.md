# For level04 in nebula

> This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)
>  
> To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04.


The source code of the program is provided below.

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {	//denies access as long as argument includes the word "token"
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));	//reads rc number of chars (where rc <= 1024) from the opened file to the buffer
  
  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);		//writes rc number of characters from the buffer to stdout
}
```

Remember, our goal is to read the file `/home/flag04/token`. Only a process running as `flag04` is allowed to read the file, as shown by its permissions `-rw------- 1 flag04 flag04    37 2011-11-20 21:52 token`. To open the file in this C program, we cannot include the word "token". 

This means we must somehow access the contents of the file through a different name.

1. `mv` can be used to rename/move the file, but we do not have permissions to do so. Ditto for `cp`. So option 1 is out.

2. `ln` can be used to create a [hard link](https://www.thegeekdiary.com/unix-file-basics-inode-soft-vs-hard-link-device-files/) of the file `token`.

![hard_link_illustration](http://www.techexams.net/technotes/linuxplus/hardlinks.gif) 

The illustration shows why we create a hard link. 

`level04@nebula:/home/flag04$ ln token ~/cheating_tok` creates a hard link `/home/level04/cheating_tok` that points to the *same* file inode as `/home/flag04/token`, essentially meaning they point to the same data.

Since `strstr("cheating_tok","token")` returns null, the program outputs the file's contents.
```
level04@nebula:/home/flag04$ ./flag04 ~/cheating_tok
06508b5e-8909-4f38-b630-fdb148a848a2
```
There we have it. We got the token. (~‾▿‾)~

### Some extra stuffs

1. Like hardlinks, symbolic links work too!

![symbolic_link_illustration](https://cdn.thegeekdiary.com/wp-content/uploads/2013/09/soft-link.png)

```
level04@nebula:/home/flag04$ ln -s /home/flag04/token /home/level04/soft_cheating_tok
level04@nebula:/home/flag04$ ./flag04 ~/soft_cheating_tok 
06508b5e-8909-4f38-b630-fdb148a848a2
```

> The open function realizes you have specified the name of a link, reads the file name contained in the link, and opens that file name instead.
[source](https://www.gnu.org/software/libc/manual/html_node/Symbolic-Links.html) 

My guess is that `strstr` did not find the substring "token" within the string "~/soft_cheating_tok", and so allowed the program to open and read the file. Once `open` received the string "~/soft_cheating_tok", it *knew* it was a symbolic symbol and reads the file name contained in the link instead. 

This is a sweet way to bypass the program security. (　＾∇＾)

2. Remember that `/home/flag04/token` and `/home/level04/cheating_tok` have the permissions - `-rw------- 1 flag04 flag04` - meaning that only processes running as `flag04` can access it. Now, even though the C program is owned by `flag04`, I executed it as `level04`, so technically, the C process should not be able to access `/home/flag04/flag04`. Yet it did. Why? (⊙.☉)7 

> Most of the time, the kernel checks only the effective user ID. For example, if a process tries to open a file, the kernel checks the effective user ID when deciding whether to let the process access the file. [source: Section 10.4 Real and Effective IDs](http://richard.esplins.org/static/downloads/linux_book.pdf)

Take a look at the permissions of the C program. The setuid bit is set `-rwsr-x--- 1 flag04 level04 7428 2011-11-20 21:52 flag04`. Whoever runs this C program is temporarily given the permissions of user `flag04`. The effective UID (EUID) of the process is the owner of the process regardless of who ran the program. So, EUID is `flag04`, and since EUID is used to evaluate whether a process should be allowed to access a file, the C program has permissions to access `/home/flag04/flag04`.

3. Simply of curiosity, I decided to run `strace ./file4 token` and `strace ./file4 ~/cheating_tok` to compare the different syscalls. The output of the latter shocked me. (⊙.☉)7 

```
level04@nebula:/home/flag04$ strace ./flag04 ~/cheating_tok
execve("./flag04", ["./flag04", "/home/level04/cheating_tok"], [/* 28 vars */]) = 0
brk(0)                                  = 0x9a52000

[...] more output
             = 0
open("/home/level04/cheating_tok", O_RDONLY) = -1 EACCES (Permission denied)
write(2, "flag04: ", 8flag04: )                 = 8
write(2, "Unable to open /home/level04/che"..., 41Unable to open /home/level04/cheating_tok) = 41
write(2, ": ", 2: )                       = 2
write(2, "Permission denied\n", 18Permission denied
)     = 18
exit_group(1)                           = ?
```
Running `strace ./file4 ~/cheating_tok` somehow got the permission denied error even though `./file ~/cheating_tok` worked perfectly. [Here's why](https://superuser.com/questions/247888/strange-strace-and-setuid-behaviour-permission-denied-under-strace-but-not-run).

END






