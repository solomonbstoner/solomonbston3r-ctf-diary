# For level11 in nebula

> The /home/flag11/flag11 binary processes standard input and executes a shell command.
>  
> There are two ways of completing this level, you may wish to do both :-)
>  
> To do this level, log in as the level11 account with the password level11. Files for this level can be found in /home/flag11.

### Source and sink

We are given the [source code](https://exploit-exercises.com/nebula/level11/) to help us solve this challenge. Woah. The source code is really long. We cannot possibly read through every line of code, so let's try the [source and sink approach](https://www.youtube.com/watch?v=ZaOtY4i5w_U) instead. The source is user input, taken in lines 21, 60, 71, and 84 of the program source code. Our goal is to execute the command `getflag` as user `flag11`. Thus, skimming through the source code, I identify line 46 to be the sink. It executes `system(buffer);`. Thus, if we somehow can get either `'/bin/sh'` or `'getflag'` into the character array `buffer`, it'd be great. Now that we've identified the potential sources and the sink, let's map our way from the source to the sink. That means dissecting the *relevant* parts of the program.

### Analysing the program

`./flag11` is a SUID program. We have a ssh folder too. That might come in handy.
```
level11@nebula:/home/flag11$ ls -al
total 17
drwxr-x--- 3 flag11 level11    92 2012-08-20 18:58 .
drwxr-xr-x 1 root   root      420 2012-08-27 07:18 ..
-rw-r--r-- 1 flag11 flag11    220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag11 flag11   3353 2011-05-18 02:54 .bashrc
-rwsr-x--- 1 flag11 level11 12135 2012-08-19 20:55 flag11
-rw-r--r-- 1 flag11 flag11    675 2011-05-18 02:54 .profile
drwxr-xr-x 2 flag11 flag11      3 2012-08-27 07:15 .ssh

```

This program takes no arguments, and accepts only input via standard input. The first line of input *must* begin with `"Content-Length: "`, otherwise it exits with an error.
```
level11@nebula:/home/flag11$ ./flag11
hello
flag11: invalid header
```

Our sink in line 46, the C function `system(buffer);`, is in the user-defined function `process(char *buffer, int length)`. It appears to do some kind of encryption on `buffer` before `system` is called.
```
void process(char *buffer, int length)
{
  unsigned int key;
  int i;
 
  key = length & 0xff;
 
  for(i = 0; i < length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
  }
 
  system(buffer);
}
```

In the code below, it appears that both branches of the if-else block call the function `process`. However, each branch manipulates the character array `buf` differently before it is passed to the callee function as an argument. Perhaps the two branches are the "two ways of completing this level". 
 
```
#define CL "Content-Length: "
char buf[1024];
[...]
length = atoi(line + strlen(CL));
if(length < sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
      err(1, "fread length");
    }
    process(buf, length);
} 
else {
    [...]
    process(mem, length);
}
```
To execute the code in the if-block, our input must be in the form `"Content-Length: y"` where `y < 1024`. To execute the code in the else-block, our input must be in the form `"Content-Length: y"` where `y >= 1024`. You might be wondering, as I did, what on Earth `atoi(line + strlen(CL))` means. So I loaded the program in gdb and observed out the return value of `atoi`. That's how I arrived at the format of the input.
```
(gdb) r
Starting program: /home/flag11/flag11 
Content-Length: 1

Breakpoint 1, 0x08048ae9 in main ()
=> 0x08048ae9 <main+174>:	89 44 24 3c	mov    DWORD PTR [esp+0x3c],eax
(gdb) p/d $eax
$1 = 1
(gdb) r
[...]
Content-Length: 5

Breakpoint 1, 0x08048ae9 in main ()
=> 0x08048ae9 <main+174>:	89 44 24 3c	mov    DWORD PTR [esp+0x3c],eax
(gdb) p/d $eax
$2 = 5
(gdb) r
[...]
Content-Length: 1024

Breakpoint 1, 0x08048ae9 in main ()
=> 0x08048ae9 <main+174>:	89 44 24 3c	mov    DWORD PTR [esp+0x3c],eax
(gdb) p/d $eax
$3 = 1024
```

### If-block

Let's start with the code in the if-block.
```
      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
      }
      process(buf, length);
```
It is important to note that `fread(buf, length, 1, stdin)` reads 1 item of data the size of `length`. Since `fread` returns the number of items of data read, it will always return 1. As long as `length` is not 1, the program will exit with error `flag11: fread length: Success` (I don't know where the word "Success" came from either).

In other words, to reach the sink as discussed above, the value of `length` can only be 1, and the character array `buf` will contain only 1 byte. Let's create an executable script called `b` in the location `/tmp`. We also add `/tmp` to the environment variable `$PATH`. That way when `system(b)` gets called, it executes the script `/tmp/b`. which runs `getflag`.
```
level11@nebula:/home/flag11$ touch /tmp/b
level11@nebula:/home/flag11$ chmod +x /tmp/b
level11@nebula:/home/flag11$ echo "getflag" > /tmp/b
level11@nebula:/home/flag11$ export PATH=/tmp:$PATH
level11@nebula:/home/flag11$ echo $PATH
/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

So this is our input to the program. We use `'c'` instead of `'b'` because the function `<process>` encrypts `'c'` to `'b'`. 
```
level11@nebula:/home/flag11$ cat ~/input1_flag11 
Content-Length: 1
c
```

We would expect it to work, but for 2 reasons, it does not.
1. `getflag` is executed as user `level11` instead of `flag11`, so we failed. It is because even though this is a SUID program, our RUID remains as `level11`. 
2. Because the program reads only 1 byte into the character array `buf`, we cannot write the null byte into it as the 2nd byte to terminate the string. Thus we have funny strings like `'b\340\345'` and `'b\300\E'`.
```
level11@nebula:/home/flag11$ cat ~/input1_flag11 | ./flag11
sh: $'b\340\345': command not found
level11@nebula:/home/flag11$ cat ~/input1_flag11 | ./flag11
sh: $'b\300\E': command not found
level11@nebula:/home/flag11$ cat ~/input1_flag11 | ./flag11
sh: $'b\220L': command not found
level11@nebula:/home/flag11$ cat ~/input1_flag11 | ./flag11
getflag is executing on a non-flag account, this doesn't count
```

So how do we proceed? 

### Else-block

Let's move on to the else-block. 

```
else {
	int blue = length;
	int pink;

	fd = getrand(&path);

	while(blue > 0) {
	  printf("blue = %d, length = %d, ", blue, length);

	  pink = fread(buf, 1, sizeof(buf), stdin);
	  printf("pink = %d\n", pink);

	  if(pink <= 0) {
	      err(1, "fread fail(blue = %d, length = %d)", blue, length);
	  }
	  write(fd, buf, pink);

	  blue -= pink;
	}

	mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
	if(mem == MAP_FAILED) {
	  err(1, "mmap");
	}
	process(mem, length);
}
```



*** Note to self ***
There are 3 ways to solve this:
1. manipulating the ssh folder
2. using LD_preload
3. ? I forgot.
