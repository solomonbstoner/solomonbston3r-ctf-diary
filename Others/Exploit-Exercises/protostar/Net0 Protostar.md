# For Net0 Protostar

Because I am new to networking, I need the source code to understand what is going on in the program.
```
#include "../common/common.c"

#define NAME "net0"
#define UID 999
#define GID 999
#define PORT 2999

void run()
{
  unsigned int i;
  unsigned int wanted;

  wanted = random();

  printf("Please send '%d' as a little endian 32bit int\n", wanted);

  if(fread(&i, sizeof(i), 1, stdin) == NULL) {
      errx(1, ":(\n");
  }

  if(i == wanted) {
      printf("Thank you sir/madam\n");
  } else {
      printf("I'm sorry, you sent %d instead\n", i);
  }
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 			
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  /* Don't do this :> */
  srandom(time(NULL));

  run();
}
```
Looking at the source code, I realised that there are no man pages for the 3 functions
1. `background_process()`
2. `serve_forever()`
3. `set_io()`

I would not be surprised if they are functions created by the programmer in the file `common.c`. 

### Unexpected problem

When I run the program, it does not print anything at all. It just terminates.
```
root@protostar:/opt/protostar/bin# ./net0
root@protostar:/opt/protostar/bin# 
```
### Analysing how the function works

Since the source code mentions *"run the process as a daemon"*, perhaps we might find its process.
```
root@protostar:/opt/protostar/bin# ps aux | grep "net0"
999       2404  0.0  0.0   1532   276 ?        Ss   07:14   0:00 ./net0
.
.
root@protostar:/opt/protostar/bin# ps aux | head -n1
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
```
And we did find it! Its USER is 999 (although `/etc/passwd` shows no user with a `UID` of 999). Funnily though, the program defined `PID` to be 999 too, but here it is 1382.

So I ran `strace` to see exactly what system calls the program makes. I'd love to understand what calls to the kernel the 3 functions actually make.
```
root@protostar:/opt/protostar/bin# strace ./net0
execve("./net0", ["./net0"], [/* 24 vars */]) = 0
brk(0)                                  = 0x804b000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe0000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13796, ...}) = 0
mmap2(NULL, 13796, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fdc000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/libc.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320m\1\0004\0\0\0"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1319176, ...}) = 0
mmap2(NULL, 1329480, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e97000
mprotect(0xb7fd5000, 4096, PROT_NONE)   = 0
mmap2(0xb7fd6000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13e) = 0xb7fd6000
mmap2(0xb7fd9000, 10568, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fd9000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e96000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e966c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb7fd6000, 8192, PROT_READ)   = 0
mprotect(0xb7ffe000, 4096, PROT_READ)   = 0
munmap(0xb7fdc000, 13796)               = 0
rt_sigaction(SIGCHLD, {0x8048dc4, [CHLD], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGPIPE, {SIG_IGN, [PIPE], SA_RESTART}, {SIG_DFL, [], 0}, 8) = 0
open("/opt/protostar/run/net0.pid", O_RDWR|O_CREAT|O_TRUNC, 0700) = 3
setgroups32(1, [999])                   = 0
setresgid32(999, 999, 999)              = 0
setresuid32(999, 999, 999)              = 0
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 2404
exit_group(0)                           = ?
root@protostar:/opt/protostar/bin#
```

The format of the strace output seems to be the following: `function_called(parameter_1, parameter_2, ...) = return_value`


Of the above strace output, this part below is of particular interest.
```
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 2404
exit_group(0)                           = ?
```
The function `clone()` (see the man pages. Btw, things like "CLONE_CHILD_SETTID" are in clone()'s man pages) gets called and returns the value `2404`. That is the `PID` of the child process. The parent process then exits, leaving the child *an orphaned process (hence the daemon)*.

To see what the child process does, we include the `-f` argument to the `strace` call. (I had to kill the process `PID 2404`, and restart `./net0` so I can trace the child process. The `PID` of the child process changes to `2427`)
```
root@protostar:/opt/protostar/bin# strace -f ./net0
. ***same as the previous strace output***
.
open("/opt/protostar/run/net0.pid", O_RDWR|O_CREAT|O_TRUNC, 0700) = 3
setgroups32(1, [999])                   = 0
setresgid32(999, 999, 999)              = 0
setresuid32(999, 999, 999)              = 0
clone(Process 2427 attached
child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 2427
[pid  2426] exit_group(0)               = ?
setsid()                                = 2427
chdir("/")                              = 0
open("/dev/null", O_RDWR)               = 4
fstat64(4, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
dup2(4, 0)                              = 0
dup2(4, 1)                              = 1
dup2(4, 2)                              = 2
close(4)                                = 0
write(3, "2427\n", 5)                   = 5
close(3)                                = 0
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(2999), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 10)                           = 0
accept(3, 
```
`accept()` waits for a connection.

### Understanding how to program works

I used `nc` (from Terminal 1) to connect to `net0` (to Terminal 2).

##### (Output from Terminal 1 -> Terminal 2)  

```
solomonbstoner@UbuntuAcer:~$ nc 192.168.56.101 2999
Please send '1647630082' as a little endian 32bit int
1234
I'm sorry, you sent 875770417 instead
solomonbstoner@UbuntuAcer:~$ 
```
##### (Output from Terminal 2 <- Terminal 1)  

```
***same as the previous strace output (the one that ended with "accept(3,"***

accept(3, {sa_family=AF_INET, sin_port=htons(39996), sin_addr=inet_addr("192.168.56.1")}, [16]) = 4
clone(Process 2428 attached
child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e96728) = 2428
[pid  2427] close(4)                    = 0
[pid  2427] accept(3,  <unfinished ...>
[pid  2428] close(3)                    = 0
[pid  2428] dup2(4, 0)                  = 0
[pid  2428] dup2(4, 1)                  = 1
[pid  2428] dup2(4, 2)                  = 2
[pid  2428] time(NULL)                  = 1518785169
[pid  2428] write(1, "Please send '1647630082' as a li"..., 54) = 54
[pid  2428] read(0, "1234", 4)          = 4
[pid  2428] write(1, "I'm sorry, you sent 875770417 in"..., 38) = 38
[pid  2428] exit_group(38)              = ?
Process 2428 detached
<... accept resumed> 0xbffff6b8, [16])  = ? ERESTARTSYS (To be restarted)
--- SIGCHLD (Child exited) @ 0 (0) ---
wait4(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 38}], 0, NULL) = 2428
sigreturn()                             = ? (mask now [])
accept(3, 
```
I shall explain what Terminal 2's output is. After a connection is made, a new child process (in this case `PID 2428`) is created to handle the connection, leaving `PID 2427` free to wait for another connection. 


According to the source code above, the winning output is *"Thank you sir/madam"*:
This is how I obtain it. (see output below)
1. Run `./net0`. It creates a daemon listening on `port 2999`.
2. I use `netcat` to connect to it.
3. I use `Python` to convert the random integer the program outputs into little endian hex values.
```
solomonbstoner@UbuntuAcer:~$ echo -e "`cat -`" | nc 192.168.56.101 2999
Please send '1878363206' as a little endian 32bit int
\x46\x8c\xf5\x6f
Thank you sir/madam
solomonbstoner@UbuntuAcer:~$ 
```
And thus, I have won the challenge.
( •_•)
( •_•)>⌐■-■
(⌐■_■)

END
